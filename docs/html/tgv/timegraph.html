<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.3" />
<title>tgv.timegraph API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tgv.timegraph</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from collections import deque
from typing import List


# --------------------------------------------- #
#              Support classes                  #
# --------------------------------------------- #

class TimeNode:
    &#34;&#34;&#34;Simple data structure for nodes than can belong to different groups over time&#34;&#34;&#34;

    def __init__(self, conns: set = None, max_step: int = -1, id=-1, name=None):
        &#34;&#34;&#34;Initializes a TimeNode structure

        :param conns: a set of connections this node has in tuple form (neighbour, time step)
        :param max_step: The maximum number of steps in the total graph
        :param id: Node identifier, should be unique over the graph this TimeNode belongs to
        :param name: (Optional) Human readable name of this node
        &#34;&#34;&#34;
        self.id = id
        self.name = name

        self.nbs = [set() for _ in range(max_step)]
        self.clusters = [None] * max_step  # type: List[TimeCluster or None]

        if conns is not None:
            for (n, t) in conns:
                self.nbs[t].add(n)

    def add_connection(self, n, t : int) -&gt; None:
        &#34;&#34;&#34;Adds a connection to this node

        :param n: node id of the neighbouring node
        :param t: time step in which this connection exists
        :return: None
        &#34;&#34;&#34;
        self.nbs[t].add(n)

class TimeCluster:
    &#34;&#34;&#34;Data structure that holds a cluster of connected nodes

    A TimeCluster in practice contains a single connected component at a single time step.
    It should keep track of incoming and outgoing connections and the nodes that belong to each connection
    Each node in members should appear in both the incoming and outgoing values, excepting the first and final layer

    :ivar id: Timecluster identifier, should be unique within the layer
    :ivar incoming: Incoming connections from the previous layer
    :ivar outgoing: Outgoing connections to the following layer
    :ivar members: Set containing all node ids that belong to this cluster
    :ivar layer: The graph layer this cluster belongs to
    &#34;&#34;&#34;

    def __init__(self, layer: int, id: int):
        &#34;&#34;&#34;Initializes a TimeCluster object

        :param layer: Layer number this cluster exists in
        :param id: identifier of this cluster, unique within layer
        &#34;&#34;&#34;
        self.id = id

        self.incoming = dict()
        self.outgoing = dict()
        self.members = set()

        self.insize = self.outsize = 0

        self.layer = layer

    def add(self, node: TimeNode):
        &#34;&#34;&#34;Adds a single node to this cluster

        :param node: identifier of the node added to this cluster
        :return:
        &#34;&#34;&#34;

        self.members.add(node)

    def add_connection(self, target, members):
        &#34;&#34;&#34;Adds a connection from or to the target timecluster for members

        If the connection already exists, the new member(s) is/are added to the existing connection.

        :param TimeCluster target: The TimeCluster to connect to. Should exist in either layer+1 or layer-1.
        :param TimeNode or set members: id or set of ids that belong to this connection.
        :return: None
        &#34;&#34;&#34;

        t = target.layer
        if type(members) == TimeNode:

            if members not in self.members:
                raise Exception(&#34;Connection contains members not in this cluster&#34;)

            if t == self.layer + 1:
                if target not in self.outgoing.keys():
                    self.outgoing[target] = set()
                self.outgoing[target].add(members)
            elif t == self.layer - 1:
                if target not in self.incoming.keys():
                    self.incoming[target] = set()
                self.incoming[target].add(members)
            else:
                raise Exception(&#34;Connection can only be added to relevant cluster&#34;)

        else:
            members = set(members)
            if len(self.members.intersection(members)) != len(members):
                raise Exception(&#34;Connection contains members not in this cluster&#34;)

            if t == self.layer + 1:
                if target not in self.outgoing.keys():
                    self.outgoing[target] = set()
                self.outgoing[target] = self.outgoing[target].union(members)
            elif t == self.layer - 1:
                if target not in self.incoming.keys():
                    self.incoming[target] = set()
                self.incoming[target] = self.incoming[target].union(members)
            else:
                raise Exception(&#34;Connection can only be added to relevant cluster&#34;)

    def update(self, min_conn_size):
        &#34;&#34;&#34;Trim connections according to some minimum connection size

        :param min_conn_size: minimum size of connection to not be removed
        :return: Whether this cluster is alive or is orphaned and has destroyed itself
        &#34;&#34;&#34;
        self.insize = self.outsize = 0
        for k, v in list(self.incoming.items()):
            if len(v) &lt; min_conn_size:
                del self.incoming[k]
            else:
                self.insize += len(v)

        for k, v in list(self.outgoing.items()):
            if len(v) &lt; min_conn_size:
                del self.outgoing[k]
            else:
                self.outsize += len(v)

        if self.insize + self.outsize == 0:
            self.destroy()
            return False
        return True

    def destroy(self):
        for n in self.members:
            n.clusters[self.layer] = None
        for nb in self.incoming.keys():
            nb.outgoing.pop(self, None)
        for nb in self.outgoing.keys():
            nb.incoming.pop(self, None)

    def __len__(self):
        return len(self.members)

    def __lt__(self, other):
        return len(self) &lt;= len(other)

    def __str__(self):
        return f&#34;TimeCluster: {self.layer}, {self.id}&#34;


# --------------------------------------------- #
#                 Main class                    #
# --------------------------------------------- #

class TimeGraph:
    &#34;&#34;&#34;Initializes a TimeGraph object

    A Timegraph object holds information about a graph that changes in discrete steps.
    Each step independently contains the full state of the graph in that step and also the clustering in that step.

    :ivar int num_steps: The number of steps in this graph
    :ivar int num_nodes: The number of nodes (not clusters) total
    :ivar nodes: List of nodes
    :ivar clusters: List of list of clusters
    &#34;&#34;&#34;
    def __init__(self, conns, nodes: int or List[str], num_steps: int, minimum_cluster_size=1, minimum_connection_size=1):
        &#34;&#34;&#34;Initializes a TimeGraph

        :param conns: Iterable of undirected connections in the form of (head, tail, timestep)
        :param nodes: Either an int (#nodes) or a list [ node_name, ... ]
        :param num_steps: Total number of steps
        &#34;&#34;&#34;

        self.num_steps = num_steps
        self.num_nodes = nodes

        self.min_clust_size = minimum_cluster_size
        self.min_conn_size = minimum_connection_size

        if isinstance(nodes, int):
            self.nodes = [TimeNode(None, num_steps, id) for id in range(nodes)]
        else:
            self.nodes = [TimeNode(max_step=num_steps, id=i, name=d) for i, d in enumerate(nodes)]


        for (f, b, t) in conns:
            self.nodes[f].add_connection(self.nodes[b], t)
            self.nodes[b].add_connection(self.nodes[f], t)

        self.layers = [self.create_layer_components(t) for t in range(self.num_steps)]
        self.connect_clusters()
        self.layers = [
            [cluster for cluster in layer if cluster.update(self.min_conn_size)]
            for layer in self.layers
        ]

        self.clusters = [x for t in range(self.num_steps) for x in self.layers[t]]

    def get_cluster(self, t, id):
        return self.layers[t][id]

    def create_layer_components(self, t: int):
        &#34;&#34;&#34;Function that creates connected components in each layer

        For a layer the connected components are built by progressively flood-filling any node that is not yet in a cluster

        :param t: Time step of this layer
        :return: List of clusters in this layer
        &#34;&#34;&#34;
        clusts = []
        seen = set()
        ctr = 0
        for node in self.nodes:
            if node.id in seen:
                continue

            seen.add(node.id)
            clust = TimeCluster(t, ctr)

            # Populate cluster through flood fill
            q = deque()
            q.append(node)
            while len(q) &gt; 0:
                n = q.pop()

                clust.add(n)
                n.clusters[t] = clust
                for nb in n.nbs[t]:
                    if nb.id not in seen:
                        q.append(nb)
                        seen.add(nb.id)

            if len(clust) &gt;= self.min_clust_size:
                clusts.append(clust)
                ctr += 1
            else:
                clust.destroy()
        return clusts

    def connect_clusters(self):
        &#34;&#34;&#34;Function that takes the clustering per layer and interconnects clusters

        A connection between two clusters is made if they are in adjacent layers and share the same node as member.

        :return: None
        &#34;&#34;&#34;

        for n in self.nodes:

            for t in range(self.num_steps - 1):
                head = n.clusters[t]
                tail = n.clusters[t + 1]

                if head is None or tail is None:
                    continue

                head.add_connection(tail, n)
                tail.add_connection(head, n)

    # Global (time graph) statistics

    def num_clusters(self):
        return len(self.clusters)

    def avg_num_clusters_per_time_step(self):
        return len(self.clusters) / self.num_steps

    def num_events(self):
        &#34;&#34;&#34; Counts events: splits, merges, starts, ends.

        A start/end = 1. A split/merge = #neighbour_clusters - 1.
        A chain of clusters excl. the ends = 0.
        &#34;&#34;&#34;

        event_count = 0

        for cluster in self.clusters:
            if len(cluster) &lt; self.min_clust_size:
                continue

            # count starts and merges
            num_incoming = 0
            for k, v in cluster.incoming.items():
                if len(k) &lt; self.min_clust_size or len(v) &lt; self.min_conn_size:
                    continue
                num_incoming += 1
            if num_incoming == 0:
                event_count += 1
            else:
                event_count += num_incoming - 1

            # count ends and splits
            num_outgoing = 0
            for k, v in cluster.outgoing.items():
                if len(k) &lt; self.min_clust_size or len(v) &lt; self.min_conn_size:
                    continue
                num_outgoing += 1
            if num_outgoing == 0:
                event_count += 1
            else:
                event_count += num_outgoing - 1

        return event_count

    def num_events_per_time_step(self):
        return self.num_events() / self.num_steps
    
    def average_relative_continuity(self):
        return sum(self.relative_continuity()) / self.num_steps
    
    def average_absolute_continuity(self):
        return sum(self.absolute_continuity()) / self.num_steps

    def average_relative_continuity_diff(self):
        return sum(self.relative_continuity_diff()) / self.num_steps

    def average_absolute_continuity_diff(self):
        return sum(self.absolute_continuity_diff()) / self.num_steps

    def normalized_absolute_continuity(self):
        return sum(self.absolute_continuity()) / sum(self.layer_num_members())

    def normalized_absolute_continuity_diff(self):
        return sum(self.absolute_continuity_diff()) / sum(self.layer_num_members())

    # Local (time step) statistics

    def layer_in_out_diff(self):
        return [abs(sum(map(lambda x: x.insize, layer)) - sum(map(lambda x: x.outsize, layer))) for layer in self.layers]

    def layer_num_clusters(self):
        return list(map(len, self.layers))

    def layer_num_members(self):
        return list(map(sum, map(lambda x: map(len, x), self.layers)))

    def relative_continuity(self):
        res = []
        for layer in self.layers:
            if len(layer) == 0:
                res.append(0.)
            else:
                res.append(sum(map(lambda c: max(map(len, c.outgoing.values()), default=1), layer))/sum(map(len, layer)))
        return res
    
    def absolute_continuity(self):
        res = []
        for layer in self.layers:
            if len(layer) == 0:
                res.append(0.)
            else:
                res.append(sum(map(lambda c: max(map(len, c.outgoing.values()), default=1), layer)))
        return res

    def relative_continuity_diff(self):
        hom = self.relative_continuity()
        res = [0.]
        for i in range(len(hom)-1):
            res.append(abs(hom[i] - hom[i+1]))
        return res
    
    def absolute_continuity_diff(self):
        con = self.absolute_continuity()
        res = [0.]
        for i in range(len(con) - 1):
            res.append(abs(con[i] - con[i + 1]))
        return res</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tgv.timegraph.TimeCluster"><code class="flex name class">
<span>class <span class="ident">TimeCluster</span></span>
<span>(</span><span>layer: int, id: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Data structure that holds a cluster of connected nodes</p>
<p>A TimeCluster in practice contains a single connected component at a single time step.
It should keep track of incoming and outgoing connections and the nodes that belong to each connection
Each node in members should appear in both the incoming and outgoing values, excepting the first and final layer</p>
<h2 id="vars">Vars:</h2>
<dl>
<dt><strong><code>id</code></strong></dt>
<dd><p>Timecluster identifier, should be unique within the layer</p></dd>
<dt><strong><code>incoming</code></strong></dt>
<dd><p>Incoming connections from the previous layer</p></dd>
<dt><strong><code>outgoing</code></strong></dt>
<dd><p>Outgoing connections to the following layer</p></dd>
<dt><strong><code>members</code></strong></dt>
<dd><p>Set containing all node ids that belong to this cluster</p></dd>
<dt><strong><code>layer</code></strong></dt>
<dd><p>The graph layer this cluster belongs to</p></dd>
</dl>
<p>Initializes a TimeCluster object</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>layer</code></strong></dt>
<dd><p>Layer number this cluster exists in</p></dd>
<dt><strong><code>id</code></strong></dt>
<dd><p>identifier of this cluster, unique within layer</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeCluster:
    &#34;&#34;&#34;Data structure that holds a cluster of connected nodes

    A TimeCluster in practice contains a single connected component at a single time step.
    It should keep track of incoming and outgoing connections and the nodes that belong to each connection
    Each node in members should appear in both the incoming and outgoing values, excepting the first and final layer

    :ivar id: Timecluster identifier, should be unique within the layer
    :ivar incoming: Incoming connections from the previous layer
    :ivar outgoing: Outgoing connections to the following layer
    :ivar members: Set containing all node ids that belong to this cluster
    :ivar layer: The graph layer this cluster belongs to
    &#34;&#34;&#34;

    def __init__(self, layer: int, id: int):
        &#34;&#34;&#34;Initializes a TimeCluster object

        :param layer: Layer number this cluster exists in
        :param id: identifier of this cluster, unique within layer
        &#34;&#34;&#34;
        self.id = id

        self.incoming = dict()
        self.outgoing = dict()
        self.members = set()

        self.insize = self.outsize = 0

        self.layer = layer

    def add(self, node: TimeNode):
        &#34;&#34;&#34;Adds a single node to this cluster

        :param node: identifier of the node added to this cluster
        :return:
        &#34;&#34;&#34;

        self.members.add(node)

    def add_connection(self, target, members):
        &#34;&#34;&#34;Adds a connection from or to the target timecluster for members

        If the connection already exists, the new member(s) is/are added to the existing connection.

        :param TimeCluster target: The TimeCluster to connect to. Should exist in either layer+1 or layer-1.
        :param TimeNode or set members: id or set of ids that belong to this connection.
        :return: None
        &#34;&#34;&#34;

        t = target.layer
        if type(members) == TimeNode:

            if members not in self.members:
                raise Exception(&#34;Connection contains members not in this cluster&#34;)

            if t == self.layer + 1:
                if target not in self.outgoing.keys():
                    self.outgoing[target] = set()
                self.outgoing[target].add(members)
            elif t == self.layer - 1:
                if target not in self.incoming.keys():
                    self.incoming[target] = set()
                self.incoming[target].add(members)
            else:
                raise Exception(&#34;Connection can only be added to relevant cluster&#34;)

        else:
            members = set(members)
            if len(self.members.intersection(members)) != len(members):
                raise Exception(&#34;Connection contains members not in this cluster&#34;)

            if t == self.layer + 1:
                if target not in self.outgoing.keys():
                    self.outgoing[target] = set()
                self.outgoing[target] = self.outgoing[target].union(members)
            elif t == self.layer - 1:
                if target not in self.incoming.keys():
                    self.incoming[target] = set()
                self.incoming[target] = self.incoming[target].union(members)
            else:
                raise Exception(&#34;Connection can only be added to relevant cluster&#34;)

    def update(self, min_conn_size):
        &#34;&#34;&#34;Trim connections according to some minimum connection size

        :param min_conn_size: minimum size of connection to not be removed
        :return: Whether this cluster is alive or is orphaned and has destroyed itself
        &#34;&#34;&#34;
        self.insize = self.outsize = 0
        for k, v in list(self.incoming.items()):
            if len(v) &lt; min_conn_size:
                del self.incoming[k]
            else:
                self.insize += len(v)

        for k, v in list(self.outgoing.items()):
            if len(v) &lt; min_conn_size:
                del self.outgoing[k]
            else:
                self.outsize += len(v)

        if self.insize + self.outsize == 0:
            self.destroy()
            return False
        return True

    def destroy(self):
        for n in self.members:
            n.clusters[self.layer] = None
        for nb in self.incoming.keys():
            nb.outgoing.pop(self, None)
        for nb in self.outgoing.keys():
            nb.incoming.pop(self, None)

    def __len__(self):
        return len(self.members)

    def __lt__(self, other):
        return len(self) &lt;= len(other)

    def __str__(self):
        return f&#34;TimeCluster: {self.layer}, {self.id}&#34;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tgv.timegraph.TimeCluster.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, node: <a title="tgv.timegraph.TimeNode" href="#tgv.timegraph.TimeNode">TimeNode</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a single node to this cluster</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>node</code></strong></dt>
<dd><p>identifier of the node added to this cluster</p></dd>
</dl>
<h2 id="returns">Returns:</h2>
<dl>
<dd></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, node: TimeNode):
    &#34;&#34;&#34;Adds a single node to this cluster

    :param node: identifier of the node added to this cluster
    :return:
    &#34;&#34;&#34;

    self.members.add(node)</code></pre>
</details>
</dd>
<dt id="tgv.timegraph.TimeCluster.add_connection"><code class="name flex">
<span>def <span class="ident">add_connection</span></span>(<span>self, target, members)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a connection from or to the target timecluster for members</p>
<p>If the connection already exists, the new member(s) is/are added to the existing connection.</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>target</code></strong> :&ensp;<code><a title="tgv.timegraph.TimeCluster" href="#tgv.timegraph.TimeCluster">TimeCluster</a></code></dt>
<dd><p>The TimeCluster to connect to. Should exist in either layer+1 or layer-1.</p></dd>
<dd>
<dl>
<dt><p>id or set of ids that belong to this connection.</p></dt>
<dt>Returns:</dt>
<dt>-----=</dt>
<dd><p>None</p></dd>
</dl>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_connection(self, target, members):
    &#34;&#34;&#34;Adds a connection from or to the target timecluster for members

    If the connection already exists, the new member(s) is/are added to the existing connection.

    :param TimeCluster target: The TimeCluster to connect to. Should exist in either layer+1 or layer-1.
    :param TimeNode or set members: id or set of ids that belong to this connection.
    :return: None
    &#34;&#34;&#34;

    t = target.layer
    if type(members) == TimeNode:

        if members not in self.members:
            raise Exception(&#34;Connection contains members not in this cluster&#34;)

        if t == self.layer + 1:
            if target not in self.outgoing.keys():
                self.outgoing[target] = set()
            self.outgoing[target].add(members)
        elif t == self.layer - 1:
            if target not in self.incoming.keys():
                self.incoming[target] = set()
            self.incoming[target].add(members)
        else:
            raise Exception(&#34;Connection can only be added to relevant cluster&#34;)

    else:
        members = set(members)
        if len(self.members.intersection(members)) != len(members):
            raise Exception(&#34;Connection contains members not in this cluster&#34;)

        if t == self.layer + 1:
            if target not in self.outgoing.keys():
                self.outgoing[target] = set()
            self.outgoing[target] = self.outgoing[target].union(members)
        elif t == self.layer - 1:
            if target not in self.incoming.keys():
                self.incoming[target] = set()
            self.incoming[target] = self.incoming[target].union(members)
        else:
            raise Exception(&#34;Connection can only be added to relevant cluster&#34;)</code></pre>
</details>
</dd>
<dt id="tgv.timegraph.TimeCluster.destroy"><code class="name flex">
<span>def <span class="ident">destroy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def destroy(self):
    for n in self.members:
        n.clusters[self.layer] = None
    for nb in self.incoming.keys():
        nb.outgoing.pop(self, None)
    for nb in self.outgoing.keys():
        nb.incoming.pop(self, None)</code></pre>
</details>
</dd>
<dt id="tgv.timegraph.TimeCluster.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, min_conn_size)</span>
</code></dt>
<dd>
<div class="desc"><p>Trim connections according to some minimum connection size</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>min_conn_size</code></strong></dt>
<dd><p>minimum size of connection to not be removed</p></dd>
</dl>
<h2 id="returns">Returns:</h2>
<dl>
<dd><p>Whether this cluster is alive or is orphaned and has destroyed itself</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, min_conn_size):
    &#34;&#34;&#34;Trim connections according to some minimum connection size

    :param min_conn_size: minimum size of connection to not be removed
    :return: Whether this cluster is alive or is orphaned and has destroyed itself
    &#34;&#34;&#34;
    self.insize = self.outsize = 0
    for k, v in list(self.incoming.items()):
        if len(v) &lt; min_conn_size:
            del self.incoming[k]
        else:
            self.insize += len(v)

    for k, v in list(self.outgoing.items()):
        if len(v) &lt; min_conn_size:
            del self.outgoing[k]
        else:
            self.outsize += len(v)

    if self.insize + self.outsize == 0:
        self.destroy()
        return False
    return True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tgv.timegraph.TimeGraph"><code class="flex name class">
<span>class <span class="ident">TimeGraph</span></span>
<span>(</span><span>conns, nodes: int, num_steps: int, minimum_cluster_size=1, minimum_connection_size=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes a TimeGraph object</p>
<p>A Timegraph object holds information about a graph that changes in discrete steps.
Each step independently contains the full state of the graph in that step and also the clustering in that step.</p>
<h2 id="vars">Vars:</h2>
<dl>
<dt><strong><code>num_steps</code></strong> :&ensp;<code>int</code></dt>
<dd><p>The number of steps in this graph</p></dd>
<dt><strong><code>num_nodes</code></strong> :&ensp;<code>int</code></dt>
<dd><p>The number of nodes (not clusters) total</p></dd>
<dt><strong><code>nodes</code></strong></dt>
<dd><p>List of nodes</p></dd>
<dt><strong><code>clusters</code></strong></dt>
<dd><p>List of list of clusters</p></dd>
</dl>
<p>Initializes a TimeGraph</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>conns</code></strong></dt>
<dd><p>Iterable of undirected connections in the form of (head, tail, timestep)</p></dd>
<dt><strong><code>nodes</code></strong></dt>
<dd><p>Either an int (#nodes) or a list [ node_name, &hellip; ]</p></dd>
<dt><strong><code>num_steps</code></strong></dt>
<dd><p>Total number of steps</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeGraph:
    &#34;&#34;&#34;Initializes a TimeGraph object

    A Timegraph object holds information about a graph that changes in discrete steps.
    Each step independently contains the full state of the graph in that step and also the clustering in that step.

    :ivar int num_steps: The number of steps in this graph
    :ivar int num_nodes: The number of nodes (not clusters) total
    :ivar nodes: List of nodes
    :ivar clusters: List of list of clusters
    &#34;&#34;&#34;
    def __init__(self, conns, nodes: int or List[str], num_steps: int, minimum_cluster_size=1, minimum_connection_size=1):
        &#34;&#34;&#34;Initializes a TimeGraph

        :param conns: Iterable of undirected connections in the form of (head, tail, timestep)
        :param nodes: Either an int (#nodes) or a list [ node_name, ... ]
        :param num_steps: Total number of steps
        &#34;&#34;&#34;

        self.num_steps = num_steps
        self.num_nodes = nodes

        self.min_clust_size = minimum_cluster_size
        self.min_conn_size = minimum_connection_size

        if isinstance(nodes, int):
            self.nodes = [TimeNode(None, num_steps, id) for id in range(nodes)]
        else:
            self.nodes = [TimeNode(max_step=num_steps, id=i, name=d) for i, d in enumerate(nodes)]


        for (f, b, t) in conns:
            self.nodes[f].add_connection(self.nodes[b], t)
            self.nodes[b].add_connection(self.nodes[f], t)

        self.layers = [self.create_layer_components(t) for t in range(self.num_steps)]
        self.connect_clusters()
        self.layers = [
            [cluster for cluster in layer if cluster.update(self.min_conn_size)]
            for layer in self.layers
        ]

        self.clusters = [x for t in range(self.num_steps) for x in self.layers[t]]

    def get_cluster(self, t, id):
        return self.layers[t][id]

    def create_layer_components(self, t: int):
        &#34;&#34;&#34;Function that creates connected components in each layer

        For a layer the connected components are built by progressively flood-filling any node that is not yet in a cluster

        :param t: Time step of this layer
        :return: List of clusters in this layer
        &#34;&#34;&#34;
        clusts = []
        seen = set()
        ctr = 0
        for node in self.nodes:
            if node.id in seen:
                continue

            seen.add(node.id)
            clust = TimeCluster(t, ctr)

            # Populate cluster through flood fill
            q = deque()
            q.append(node)
            while len(q) &gt; 0:
                n = q.pop()

                clust.add(n)
                n.clusters[t] = clust
                for nb in n.nbs[t]:
                    if nb.id not in seen:
                        q.append(nb)
                        seen.add(nb.id)

            if len(clust) &gt;= self.min_clust_size:
                clusts.append(clust)
                ctr += 1
            else:
                clust.destroy()
        return clusts

    def connect_clusters(self):
        &#34;&#34;&#34;Function that takes the clustering per layer and interconnects clusters

        A connection between two clusters is made if they are in adjacent layers and share the same node as member.

        :return: None
        &#34;&#34;&#34;

        for n in self.nodes:

            for t in range(self.num_steps - 1):
                head = n.clusters[t]
                tail = n.clusters[t + 1]

                if head is None or tail is None:
                    continue

                head.add_connection(tail, n)
                tail.add_connection(head, n)

    # Global (time graph) statistics

    def num_clusters(self):
        return len(self.clusters)

    def avg_num_clusters_per_time_step(self):
        return len(self.clusters) / self.num_steps

    def num_events(self):
        &#34;&#34;&#34; Counts events: splits, merges, starts, ends.

        A start/end = 1. A split/merge = #neighbour_clusters - 1.
        A chain of clusters excl. the ends = 0.
        &#34;&#34;&#34;

        event_count = 0

        for cluster in self.clusters:
            if len(cluster) &lt; self.min_clust_size:
                continue

            # count starts and merges
            num_incoming = 0
            for k, v in cluster.incoming.items():
                if len(k) &lt; self.min_clust_size or len(v) &lt; self.min_conn_size:
                    continue
                num_incoming += 1
            if num_incoming == 0:
                event_count += 1
            else:
                event_count += num_incoming - 1

            # count ends and splits
            num_outgoing = 0
            for k, v in cluster.outgoing.items():
                if len(k) &lt; self.min_clust_size or len(v) &lt; self.min_conn_size:
                    continue
                num_outgoing += 1
            if num_outgoing == 0:
                event_count += 1
            else:
                event_count += num_outgoing - 1

        return event_count

    def num_events_per_time_step(self):
        return self.num_events() / self.num_steps
    
    def average_relative_continuity(self):
        return sum(self.relative_continuity()) / self.num_steps
    
    def average_absolute_continuity(self):
        return sum(self.absolute_continuity()) / self.num_steps

    def average_relative_continuity_diff(self):
        return sum(self.relative_continuity_diff()) / self.num_steps

    def average_absolute_continuity_diff(self):
        return sum(self.absolute_continuity_diff()) / self.num_steps

    def normalized_absolute_continuity(self):
        return sum(self.absolute_continuity()) / sum(self.layer_num_members())

    def normalized_absolute_continuity_diff(self):
        return sum(self.absolute_continuity_diff()) / sum(self.layer_num_members())

    # Local (time step) statistics

    def layer_in_out_diff(self):
        return [abs(sum(map(lambda x: x.insize, layer)) - sum(map(lambda x: x.outsize, layer))) for layer in self.layers]

    def layer_num_clusters(self):
        return list(map(len, self.layers))

    def layer_num_members(self):
        return list(map(sum, map(lambda x: map(len, x), self.layers)))

    def relative_continuity(self):
        res = []
        for layer in self.layers:
            if len(layer) == 0:
                res.append(0.)
            else:
                res.append(sum(map(lambda c: max(map(len, c.outgoing.values()), default=1), layer))/sum(map(len, layer)))
        return res
    
    def absolute_continuity(self):
        res = []
        for layer in self.layers:
            if len(layer) == 0:
                res.append(0.)
            else:
                res.append(sum(map(lambda c: max(map(len, c.outgoing.values()), default=1), layer)))
        return res

    def relative_continuity_diff(self):
        hom = self.relative_continuity()
        res = [0.]
        for i in range(len(hom)-1):
            res.append(abs(hom[i] - hom[i+1]))
        return res
    
    def absolute_continuity_diff(self):
        con = self.absolute_continuity()
        res = [0.]
        for i in range(len(con) - 1):
            res.append(abs(con[i] - con[i + 1]))
        return res</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tgv.timegraph.TimeGraph.absolute_continuity"><code class="name flex">
<span>def <span class="ident">absolute_continuity</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def absolute_continuity(self):
    res = []
    for layer in self.layers:
        if len(layer) == 0:
            res.append(0.)
        else:
            res.append(sum(map(lambda c: max(map(len, c.outgoing.values()), default=1), layer)))
    return res</code></pre>
</details>
</dd>
<dt id="tgv.timegraph.TimeGraph.absolute_continuity_diff"><code class="name flex">
<span>def <span class="ident">absolute_continuity_diff</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def absolute_continuity_diff(self):
    con = self.absolute_continuity()
    res = [0.]
    for i in range(len(con) - 1):
        res.append(abs(con[i] - con[i + 1]))
    return res</code></pre>
</details>
</dd>
<dt id="tgv.timegraph.TimeGraph.average_absolute_continuity"><code class="name flex">
<span>def <span class="ident">average_absolute_continuity</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def average_absolute_continuity(self):
    return sum(self.absolute_continuity()) / self.num_steps</code></pre>
</details>
</dd>
<dt id="tgv.timegraph.TimeGraph.average_absolute_continuity_diff"><code class="name flex">
<span>def <span class="ident">average_absolute_continuity_diff</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def average_absolute_continuity_diff(self):
    return sum(self.absolute_continuity_diff()) / self.num_steps</code></pre>
</details>
</dd>
<dt id="tgv.timegraph.TimeGraph.average_relative_continuity"><code class="name flex">
<span>def <span class="ident">average_relative_continuity</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def average_relative_continuity(self):
    return sum(self.relative_continuity()) / self.num_steps</code></pre>
</details>
</dd>
<dt id="tgv.timegraph.TimeGraph.average_relative_continuity_diff"><code class="name flex">
<span>def <span class="ident">average_relative_continuity_diff</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def average_relative_continuity_diff(self):
    return sum(self.relative_continuity_diff()) / self.num_steps</code></pre>
</details>
</dd>
<dt id="tgv.timegraph.TimeGraph.avg_num_clusters_per_time_step"><code class="name flex">
<span>def <span class="ident">avg_num_clusters_per_time_step</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def avg_num_clusters_per_time_step(self):
    return len(self.clusters) / self.num_steps</code></pre>
</details>
</dd>
<dt id="tgv.timegraph.TimeGraph.connect_clusters"><code class="name flex">
<span>def <span class="ident">connect_clusters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that takes the clustering per layer and interconnects clusters</p>
<p>A connection between two clusters is made if they are in adjacent layers and share the same node as member.</p>
<h2 id="returns">Returns:</h2>
<dl>
<dd><p>None</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect_clusters(self):
    &#34;&#34;&#34;Function that takes the clustering per layer and interconnects clusters

    A connection between two clusters is made if they are in adjacent layers and share the same node as member.

    :return: None
    &#34;&#34;&#34;

    for n in self.nodes:

        for t in range(self.num_steps - 1):
            head = n.clusters[t]
            tail = n.clusters[t + 1]

            if head is None or tail is None:
                continue

            head.add_connection(tail, n)
            tail.add_connection(head, n)</code></pre>
</details>
</dd>
<dt id="tgv.timegraph.TimeGraph.create_layer_components"><code class="name flex">
<span>def <span class="ident">create_layer_components</span></span>(<span>self, t: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that creates connected components in each layer</p>
<p>For a layer the connected components are built by progressively flood-filling any node that is not yet in a cluster</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>t</code></strong></dt>
<dd><p>Time step of this layer</p></dd>
</dl>
<h2 id="returns">Returns:</h2>
<dl>
<dd><p>List of clusters in this layer</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_layer_components(self, t: int):
    &#34;&#34;&#34;Function that creates connected components in each layer

    For a layer the connected components are built by progressively flood-filling any node that is not yet in a cluster

    :param t: Time step of this layer
    :return: List of clusters in this layer
    &#34;&#34;&#34;
    clusts = []
    seen = set()
    ctr = 0
    for node in self.nodes:
        if node.id in seen:
            continue

        seen.add(node.id)
        clust = TimeCluster(t, ctr)

        # Populate cluster through flood fill
        q = deque()
        q.append(node)
        while len(q) &gt; 0:
            n = q.pop()

            clust.add(n)
            n.clusters[t] = clust
            for nb in n.nbs[t]:
                if nb.id not in seen:
                    q.append(nb)
                    seen.add(nb.id)

        if len(clust) &gt;= self.min_clust_size:
            clusts.append(clust)
            ctr += 1
        else:
            clust.destroy()
    return clusts</code></pre>
</details>
</dd>
<dt id="tgv.timegraph.TimeGraph.get_cluster"><code class="name flex">
<span>def <span class="ident">get_cluster</span></span>(<span>self, t, id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cluster(self, t, id):
    return self.layers[t][id]</code></pre>
</details>
</dd>
<dt id="tgv.timegraph.TimeGraph.layer_in_out_diff"><code class="name flex">
<span>def <span class="ident">layer_in_out_diff</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def layer_in_out_diff(self):
    return [abs(sum(map(lambda x: x.insize, layer)) - sum(map(lambda x: x.outsize, layer))) for layer in self.layers]</code></pre>
</details>
</dd>
<dt id="tgv.timegraph.TimeGraph.layer_num_clusters"><code class="name flex">
<span>def <span class="ident">layer_num_clusters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def layer_num_clusters(self):
    return list(map(len, self.layers))</code></pre>
</details>
</dd>
<dt id="tgv.timegraph.TimeGraph.layer_num_members"><code class="name flex">
<span>def <span class="ident">layer_num_members</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def layer_num_members(self):
    return list(map(sum, map(lambda x: map(len, x), self.layers)))</code></pre>
</details>
</dd>
<dt id="tgv.timegraph.TimeGraph.normalized_absolute_continuity"><code class="name flex">
<span>def <span class="ident">normalized_absolute_continuity</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalized_absolute_continuity(self):
    return sum(self.absolute_continuity()) / sum(self.layer_num_members())</code></pre>
</details>
</dd>
<dt id="tgv.timegraph.TimeGraph.normalized_absolute_continuity_diff"><code class="name flex">
<span>def <span class="ident">normalized_absolute_continuity_diff</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalized_absolute_continuity_diff(self):
    return sum(self.absolute_continuity_diff()) / sum(self.layer_num_members())</code></pre>
</details>
</dd>
<dt id="tgv.timegraph.TimeGraph.num_clusters"><code class="name flex">
<span>def <span class="ident">num_clusters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_clusters(self):
    return len(self.clusters)</code></pre>
</details>
</dd>
<dt id="tgv.timegraph.TimeGraph.num_events"><code class="name flex">
<span>def <span class="ident">num_events</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Counts events: splits, merges, starts, ends.</p>
<p>A start/end = 1. A split/merge = #neighbour_clusters - 1.
A chain of clusters excl. the ends = 0.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_events(self):
    &#34;&#34;&#34; Counts events: splits, merges, starts, ends.

    A start/end = 1. A split/merge = #neighbour_clusters - 1.
    A chain of clusters excl. the ends = 0.
    &#34;&#34;&#34;

    event_count = 0

    for cluster in self.clusters:
        if len(cluster) &lt; self.min_clust_size:
            continue

        # count starts and merges
        num_incoming = 0
        for k, v in cluster.incoming.items():
            if len(k) &lt; self.min_clust_size or len(v) &lt; self.min_conn_size:
                continue
            num_incoming += 1
        if num_incoming == 0:
            event_count += 1
        else:
            event_count += num_incoming - 1

        # count ends and splits
        num_outgoing = 0
        for k, v in cluster.outgoing.items():
            if len(k) &lt; self.min_clust_size or len(v) &lt; self.min_conn_size:
                continue
            num_outgoing += 1
        if num_outgoing == 0:
            event_count += 1
        else:
            event_count += num_outgoing - 1

    return event_count</code></pre>
</details>
</dd>
<dt id="tgv.timegraph.TimeGraph.num_events_per_time_step"><code class="name flex">
<span>def <span class="ident">num_events_per_time_step</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_events_per_time_step(self):
    return self.num_events() / self.num_steps</code></pre>
</details>
</dd>
<dt id="tgv.timegraph.TimeGraph.relative_continuity"><code class="name flex">
<span>def <span class="ident">relative_continuity</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def relative_continuity(self):
    res = []
    for layer in self.layers:
        if len(layer) == 0:
            res.append(0.)
        else:
            res.append(sum(map(lambda c: max(map(len, c.outgoing.values()), default=1), layer))/sum(map(len, layer)))
    return res</code></pre>
</details>
</dd>
<dt id="tgv.timegraph.TimeGraph.relative_continuity_diff"><code class="name flex">
<span>def <span class="ident">relative_continuity_diff</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def relative_continuity_diff(self):
    hom = self.relative_continuity()
    res = [0.]
    for i in range(len(hom)-1):
        res.append(abs(hom[i] - hom[i+1]))
    return res</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tgv.timegraph.TimeNode"><code class="flex name class">
<span>class <span class="ident">TimeNode</span></span>
<span>(</span><span>conns: set = None, max_step: int = -1, id=-1, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Simple data structure for nodes than can belong to different groups over time</p>
<p>Initializes a TimeNode structure</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>conns</code></strong></dt>
<dd><p>a set of connections this node has in tuple form (neighbour, time step)</p></dd>
<dt><strong><code>max_step</code></strong></dt>
<dd><p>The maximum number of steps in the total graph</p></dd>
<dt><strong><code>id</code></strong></dt>
<dd><p>Node identifier, should be unique over the graph this TimeNode belongs to</p></dd>
<dt><strong><code>name</code></strong></dt>
<dd><p>(Optional) Human readable name of this node</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeNode:
    &#34;&#34;&#34;Simple data structure for nodes than can belong to different groups over time&#34;&#34;&#34;

    def __init__(self, conns: set = None, max_step: int = -1, id=-1, name=None):
        &#34;&#34;&#34;Initializes a TimeNode structure

        :param conns: a set of connections this node has in tuple form (neighbour, time step)
        :param max_step: The maximum number of steps in the total graph
        :param id: Node identifier, should be unique over the graph this TimeNode belongs to
        :param name: (Optional) Human readable name of this node
        &#34;&#34;&#34;
        self.id = id
        self.name = name

        self.nbs = [set() for _ in range(max_step)]
        self.clusters = [None] * max_step  # type: List[TimeCluster or None]

        if conns is not None:
            for (n, t) in conns:
                self.nbs[t].add(n)

    def add_connection(self, n, t : int) -&gt; None:
        &#34;&#34;&#34;Adds a connection to this node

        :param n: node id of the neighbouring node
        :param t: time step in which this connection exists
        :return: None
        &#34;&#34;&#34;
        self.nbs[t].add(n)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tgv.timegraph.TimeNode.add_connection"><code class="name flex">
<span>def <span class="ident">add_connection</span></span>(<span>self, n, t: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a connection to this node</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>n</code></strong></dt>
<dd><p>node id of the neighbouring node</p></dd>
<dt><strong><code>t</code></strong></dt>
<dd><p>time step in which this connection exists</p></dd>
</dl>
<h2 id="returns">Returns:</h2>
<dl>
<dd><p>None</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_connection(self, n, t : int) -&gt; None:
    &#34;&#34;&#34;Adds a connection to this node

    :param n: node id of the neighbouring node
    :param t: time step in which this connection exists
    :return: None
    &#34;&#34;&#34;
    self.nbs[t].add(n)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tgv" href="index.html">tgv</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tgv.timegraph.TimeCluster" href="#tgv.timegraph.TimeCluster">TimeCluster</a></code></h4>
<ul class="">
<li><code><a title="tgv.timegraph.TimeCluster.add" href="#tgv.timegraph.TimeCluster.add">add</a></code></li>
<li><code><a title="tgv.timegraph.TimeCluster.add_connection" href="#tgv.timegraph.TimeCluster.add_connection">add_connection</a></code></li>
<li><code><a title="tgv.timegraph.TimeCluster.destroy" href="#tgv.timegraph.TimeCluster.destroy">destroy</a></code></li>
<li><code><a title="tgv.timegraph.TimeCluster.update" href="#tgv.timegraph.TimeCluster.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tgv.timegraph.TimeGraph" href="#tgv.timegraph.TimeGraph">TimeGraph</a></code></h4>
<ul class="">
<li><code><a title="tgv.timegraph.TimeGraph.absolute_continuity" href="#tgv.timegraph.TimeGraph.absolute_continuity">absolute_continuity</a></code></li>
<li><code><a title="tgv.timegraph.TimeGraph.absolute_continuity_diff" href="#tgv.timegraph.TimeGraph.absolute_continuity_diff">absolute_continuity_diff</a></code></li>
<li><code><a title="tgv.timegraph.TimeGraph.average_absolute_continuity" href="#tgv.timegraph.TimeGraph.average_absolute_continuity">average_absolute_continuity</a></code></li>
<li><code><a title="tgv.timegraph.TimeGraph.average_absolute_continuity_diff" href="#tgv.timegraph.TimeGraph.average_absolute_continuity_diff">average_absolute_continuity_diff</a></code></li>
<li><code><a title="tgv.timegraph.TimeGraph.average_relative_continuity" href="#tgv.timegraph.TimeGraph.average_relative_continuity">average_relative_continuity</a></code></li>
<li><code><a title="tgv.timegraph.TimeGraph.average_relative_continuity_diff" href="#tgv.timegraph.TimeGraph.average_relative_continuity_diff">average_relative_continuity_diff</a></code></li>
<li><code><a title="tgv.timegraph.TimeGraph.avg_num_clusters_per_time_step" href="#tgv.timegraph.TimeGraph.avg_num_clusters_per_time_step">avg_num_clusters_per_time_step</a></code></li>
<li><code><a title="tgv.timegraph.TimeGraph.connect_clusters" href="#tgv.timegraph.TimeGraph.connect_clusters">connect_clusters</a></code></li>
<li><code><a title="tgv.timegraph.TimeGraph.create_layer_components" href="#tgv.timegraph.TimeGraph.create_layer_components">create_layer_components</a></code></li>
<li><code><a title="tgv.timegraph.TimeGraph.get_cluster" href="#tgv.timegraph.TimeGraph.get_cluster">get_cluster</a></code></li>
<li><code><a title="tgv.timegraph.TimeGraph.layer_in_out_diff" href="#tgv.timegraph.TimeGraph.layer_in_out_diff">layer_in_out_diff</a></code></li>
<li><code><a title="tgv.timegraph.TimeGraph.layer_num_clusters" href="#tgv.timegraph.TimeGraph.layer_num_clusters">layer_num_clusters</a></code></li>
<li><code><a title="tgv.timegraph.TimeGraph.layer_num_members" href="#tgv.timegraph.TimeGraph.layer_num_members">layer_num_members</a></code></li>
<li><code><a title="tgv.timegraph.TimeGraph.normalized_absolute_continuity" href="#tgv.timegraph.TimeGraph.normalized_absolute_continuity">normalized_absolute_continuity</a></code></li>
<li><code><a title="tgv.timegraph.TimeGraph.normalized_absolute_continuity_diff" href="#tgv.timegraph.TimeGraph.normalized_absolute_continuity_diff">normalized_absolute_continuity_diff</a></code></li>
<li><code><a title="tgv.timegraph.TimeGraph.num_clusters" href="#tgv.timegraph.TimeGraph.num_clusters">num_clusters</a></code></li>
<li><code><a title="tgv.timegraph.TimeGraph.num_events" href="#tgv.timegraph.TimeGraph.num_events">num_events</a></code></li>
<li><code><a title="tgv.timegraph.TimeGraph.num_events_per_time_step" href="#tgv.timegraph.TimeGraph.num_events_per_time_step">num_events_per_time_step</a></code></li>
<li><code><a title="tgv.timegraph.TimeGraph.relative_continuity" href="#tgv.timegraph.TimeGraph.relative_continuity">relative_continuity</a></code></li>
<li><code><a title="tgv.timegraph.TimeGraph.relative_continuity_diff" href="#tgv.timegraph.TimeGraph.relative_continuity_diff">relative_continuity_diff</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tgv.timegraph.TimeNode" href="#tgv.timegraph.TimeNode">TimeNode</a></code></h4>
<ul class="">
<li><code><a title="tgv.timegraph.TimeNode.add_connection" href="#tgv.timegraph.TimeNode.add_connection">add_connection</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.3</a>.</p>
</footer>
</body>
</html>