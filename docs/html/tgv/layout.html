<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.3" />
<title>tgv.layout API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tgv.layout</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations

import math
from collections import Counter, deque
from numbers import Number
from typing import List, Set, Dict, Optional, Tuple, Collection

import cairocffi as cairo

from tgv.timegraph import TimeGraph, TimeCluster
from tgv.drawing_utils import coloured_bezier

INCOMING = FORWARD = True
OUTGOING = BACKWARD = False


class NotRootException(Exception):
    pass


class UnorderedException(Exception):
    pass


class NotEndpointException(Exception):
    pass


class SizedConnectionCluster:
    def __init__(self, tc: TimeCluster, height_method):
        # Link to original TimeCluster and vice versa
        self.tc = tc
        tc.sc = self

        # Connection properties
        self.incoming = dict()  # Filled by build(), k is SugiyamaCluster, v is set of TimeNodes
        self.outgoing = dict()  # Filled by build(), k is SugiyamaCluster, v is set of TimeNodes
        self.neighbours = dict()  # Filled by build(), k is SugiyamaCluster, v is set of TimeNodes

        self.insize = 0  # Filled by build(), number of incoming connections
        self.outsize = 0  # Filled by build(), number of outgoing connections

        self.largest_incoming = 0  # Filled by build(), size of the largest incoming connection
        self.largest_outgoing = 0  # Filled by build(), size of the largest outgoing connection

        self.members = self.tc.members  # Set of TimeNodes in this cluster

        # Order properties
        self.rank = -1
        self.inrank = -1
        self.outrank = -1
        self.wanted_direction = 0

        # Alignment properties
        self.root = self
        self.align = self
        self.chain_length = 1

        # Location properties
        self.x = -1
        self.y = -1
        self._y = -1  # storage value if self.y should not be changed immediately

        # Drawing properties
        self.draw_size = self.draw_height(height_method)

    def draw_height(self, method: str) -&gt; float:
        &#34;&#34;&#34;
        Determine vertical size of this cluster depending on its size

        :param method: The function to apply to the member size. Accepts &#39;linear&#39;, &#39;sqrt&#39;, &#39;log&#39; or &#39;constant&#39;
        :return: Size of this cluster
        &#34;&#34;&#34;
        if method == &#39;linear&#39;:
            return len(self.members)
        elif method == &#39;sqrt&#39;:
            return math.sqrt(len(self.members))
        elif method == &#39;log&#39;:
            return math.log(len(self.members))
        elif method == &#39;constant&#39;:
            return 1.
        else:
            return 0.

    def build(self) -&gt; None:
        &#34;&#34;&#34;
        Builds the neighbour set and related data from the base TimeCluster

        &#34;&#34;&#34;
        for c, connection_nodes in self.tc.incoming.items():
            self.incoming[c.sc] = connection_nodes

        for c, connection_nodes in self.tc.outgoing.items():
            self.outgoing[c.sc] = connection_nodes

        self.insize = self.tc.insize
        self.outsize = self.tc.outsize
        self.neighbours = {**self.incoming, **self.outgoing}
        self.largest_incoming = max(map(len, self.incoming.values()), default=0)
        self.largest_outgoing = max(map(len, self.outgoing.values()), default=0)

    def update_cluster_ranks(self) -&gt; Tuple[float, float]:
        &#34;&#34;&#34;
        Update the rank information of this cluster

        Rank information is determined by the average rank of the incoming and outgoing connections. Since ranks can
        vary wildly between layers, inrank and outrank can not be compared to each other or this clusters own rank.

        :return: The average incoming rank and the average outgoing rank, or -1 for either if it has none on that side
        &#34;&#34;&#34;
        if self.insize &gt; 0:
            inrank = sum([nb.rank * len(conn) for nb, conn in self.incoming.items()]) / self.insize
        else:
            inrank = -1

        if self.outsize &gt; 0:
            outrank = sum([n.rank * len(l) for n, l in self.outgoing.items()]) / self.outsize
        else:
            outrank = -1

        self.inrank = inrank
        self.outrank = outrank
        return inrank, outrank

    def update_cluster_ranks_median(self) -&gt; Tuple[float, float]:
        &#34;&#34;&#34;
        Update the rank information of this cluster using median instead of average

        Rank information is determined by the median rank of the incoming and outgoing connections. Since ranks can
        vary wildly between layers, inrank and outrank can not be compared to each other or this clusters own rank.

        :return: The median incoming rank and the median outgoing rank
        &#34;&#34;&#34;
        inc = list(self.incoming.items())
        out = list(self.outgoing.items())

        self.inrank, self.outrank = self.weighted_median_rank(inc), self.weighted_median_rank(out)
        return self.inrank, self.outrank

    @staticmethod
    def weighted_median_rank(nbs: List[(SizedConnectionCluster, Set)]) -&gt; float:
        &#34;&#34;&#34;
        Of a list of neighbours, return the median ranked neighbour adjusted for integer weighted connections

        Instead of taking the median connection, this function finds the connection that the median ranked node belongs to
        :param nbs: list of neighbours and connection members
        :return: The rank of the cluster of which the median node is connected
        &#34;&#34;&#34;
        if len(nbs) == 0:
            return -1

        nbs.sort(key=lambda x: x[0].rank)
        inc_total = sum(map(lambda x: len(x[1]), nbs))
        ptr = 0
        inc_sum = 0.
        while inc_sum &lt; inc_total / 2.:
            inc_sum += len(nbs[ptr][1])
            ptr += 1
        if inc_total % 2 == 0 and inc_sum == inc_total // 2:
            med = (nbs[ptr][0].rank + nbs[ptr - 1][0].rank) / 2.
        else:
            med = nbs[ptr - 1][0].rank
        return med

    def reset_alignment(self) -&gt; None:
        &#34;&#34;&#34;
        Reset the values used in determining alignment to their default values
        &#34;&#34;&#34;
        self.root = self
        self.align = self
        self.chain_length = 1

    def reset_endpoint(self) -&gt; None:
        &#34;&#34;&#34;
        If this cluster is the second to last of a chain, make it the last in the chain
        The cluster removed from the chain should be reset separately
        &#34;&#34;&#34;
        if self.align == self.root or self.align.align != self.align.root:
            return
        self.align = self.root
        self.root.chain_length = max(1, self.root.chain_length - 1)

    def largest_median_connection(self, lower=True, direction=INCOMING) -&gt; (SizedConnectionCluster, int):
        &#34;&#34;&#34;
        Returns the cluster with the largest connection to this one.

        If multiple candidates with equal connection weight exist, returns the lower median in ordering

        :param self: Cluster to find the median median of
        :param lower: Flag to take either the upper or lower median if even amount
        :param direction: Flag for direction. True is incoming, False is outgoing
        :return: The cluster and the weight of the connection
        &#34;&#34;&#34;

        if direction:  # is INCOMING
            connections = list(self.incoming.items())
        else:  # is OUTGOING
            connections = list(self.outgoing.items())

        if len(connections) == 0:
            return None, 0

        connections.sort(key=lambda x: (len(x[1]), x[0].rank), reverse=True)
        ptr = 0
        while ptr &lt; len(connections) and len(connections[ptr][1]) == len(connections[0][1]):
            ptr += 1

        brother = connections[(ptr - (1 if lower else 0)) // 2][0]
        connsize = len(connections[0][1])
        return brother, connsize

    def align_with(self, next_cluster: SizedConnectionCluster) -&gt; None:
        &#34;&#34;&#34;
        puts next_cluster as the next link in this chain, if self is an endpoint

        :param next_cluster: The cluster to align with current chain
        &#34;&#34;&#34;
        if self.align != self.root:
            raise NotEndpointException(
                f&#34;Can only align if self is an endpoint, but {self} is aligned with {self.align}&#34;)
        self.align = next_cluster
        next_cluster.root = self.root
        next_cluster.align = self.root
        self.root.chain_length += 1

    def update_wanted_direction(self) -&gt; int:
        &#34;&#34;&#34;
        Function to calculate which direction an alignment would like to move in depending on the ranks of its connections

        :return: The direction (positive is downwards, negative is upwards) and strength of the direction
        &#34;&#34;&#34;
        if self.root != self:
            raise NotRootException(&#34;You can only call wanted_direction on an alignment root.&#34;)

        # l holds the alignment for quick access in all directions
        l = []

        cluster = self
        while True:
            l.append(cluster)
            if cluster.align == self:
                break
            cluster = cluster.align

        total = 0
        for i in range(1, len(l)):
            cluster = l[i]
            # Compare incoming connections to the rank of the previous in the alignment
            for k, v in l[i].incoming.items():
                total += len(v) * (k.rank - l[i - 1].rank)

        for i in range(0, len(l) - 1):
            # Compare outgoing connections to the rank of the next in the alignment
            for k, v in l[i].outgoing.items():
                total += len(v) * (k.rank - l[i + 1].rank)

        # The first and last elements of l are not aligned further for a reason
        # So we have to factor in the direction of where this alignment would have liked to go
        left, _ = l[0].largest_median_connection(direction=INCOMING)
        if left is not None and left.align.tc.layer == l[0].tc.layer:
            total += left.align.rank - l[0].rank

        right, _ = l[-1].largest_median_connection(direction=OUTGOING)
        if right is not None and right.root.tc.layer &lt;= l[-1].tc.layer:
            prev = right.root
            while prev.align != right:
                prev = prev.align
            total += prev.rank - l[-1].rank

        self.wanted_direction = total
        return total

    def pos(self) -&gt; Tuple[float, float]:
        &#34;&#34;&#34;
        Returns the current x and y coordinate of this cluster. This should be treated as the center of this cluster.

        :return: tuple of x and y coordinate
        &#34;&#34;&#34;
        return self.x, self.y

    def __str__(self):
        return f&#34;SugiyamaCluster {str((self.tc.layer, self.tc.id))}/{self.rank} at {self.y}&#34;

    def __len__(self):
        return len(self.members)


class SizedConnectionLayout:

    ####################################################################################################################
    # -------------------------------------------- init Functions ---------------------------------------------------- #
    ####################################################################################################################

    def __init__(self, g: TimeGraph,
                 line_width=-1., line_spacing=0.0,
                 line_curviness=0.3,
                 horizontal_density=2., vertical_density=1.,
                 cluster_width=-1,
                 cluster_height_method=&#39;linear&#39;,
                 font_size=-1,
                 verbose=False):

        # Set basic information from the time graph
        self.g = g
        self.num_layers = self.g.num_steps

        # Set different collection objects
        self.clusters, self.layers = self.build_clusters(cluster_height_method)
        self.ordered = []  # Filled by reset_order()
        self.reset_order()

        # Set flags
        self.is_ordered = False
        self.is_aligned = False
        self.is_located = False

        # General info
        max_cluster = max(self.clusters, key=len)
        self.max_cluster_height = max_cluster.draw_size
        self.max_cluster_size = len(max_cluster)  # Amount of elements in cluster
        self.max_bundle_size = max(
            [max(map(len, cluster.neighbours.values())) for cluster in self.clusters])  # Amount elements in connection
        self.max_num_connection = max(
            map(lambda x: len(x.incoming), self.clusters))  # Amount of connections on one side of a cluster

        # Location settings
        # 1 point = 0.352 mm, or 3 points = 1 mm
        self.xseparation_frac = horizontal_density  # (fraction) from user
        self.yseparation_frac = vertical_density  # (fraction) from user
        self.line_spacing = line_spacing  # (fraction) from user; relative to line_width
        self.line_width = line_width if line_width &gt;= 0. else self.auto_line_width()  # (in points) from user
        self.line_curviness = line_curviness  # (fraction) from user; (see curve_offset)

        self.scale = 1.  # (fraction) Scale the image

        # automatically set some drawing parameters based on the graph data
        self.yseparation = self.max_bundle_size * self.line_width * self.yseparation_frac  # (in points)
        self.xseparation = self.max_bundle_size * self.line_width * self.xseparation_frac  # (in points)
        self.ymargin = self.yseparation  # (in points)
        self.xmargin = self.xseparation  # (in points) small
        self.cluster_width = cluster_width if cluster_width &gt;= 0 else self.auto_cluster_width()  # (in points) from user

        self.curve_offset = self.xseparation * self.line_curviness  # (in points)

        self.font_size = font_size if font_size &gt;= 0 else self.xseparation * 0.6  # (in points) from user

        self.height = 0  # (in points) computed automatically from data
        self.width = 0  # (in points) computed automatically from data

        self.default_line_color = (1., 0., 0., 1.)  # (0, 0.4, 0.8, 1) # r, g, b, a
        self.default_cluster_color = (0., 0., 0., 1.)  # r, g, b, a

    def auto_line_width(self) -&gt; float:
        &#34;&#34;&#34;
        Calculates automatically the largest possible line width.

         The line width is calculated such that the outgoing or incoming connection can only be as big as the cluster.
        Assumes that the connection width is linear.

        :return: The maximum reasonable line width
        &#34;&#34;&#34;
        max_line_width = float(&#39;inf&#39;)
        for cluster in self.clusters:
            line_width_in = line_width_out = float(&#39;inf&#39;)
            if cluster.insize &gt; 0:
                line_width_in = cluster.draw_size / (cluster.insize + self.line_spacing * (len(cluster.incoming) - 1))
            if cluster.outsize &gt; 0:
                line_width_out = cluster.draw_size / (cluster.outsize + self.line_spacing * (len(cluster.outgoing) - 1))
            max_line_width = min(max_line_width, line_width_in, line_width_out)
        return max_line_width

    def auto_cluster_width(self) -&gt; float:
        &#34;&#34;&#34;
        Simple default cluster width

        :return: width that is 5% of the xseparation
        &#34;&#34;&#34;
        return self.xseparation * 0.05

    def build_clusters(self, height_method: str) -&gt; Tuple[List[SizedConnectionCluster], List[List[SizedConnectionCluster]]]:
        &#34;&#34;&#34;
        Create Sugiyamaclusters from the underlying graph

        :param height_method: the string to pass to the cluster for it to determine its vertical size
        :return: List of all clusters, first flattened, second in layers
        :rtype: str
        &#34;&#34;&#34;
        layers = [
            [SizedConnectionCluster(self.g.layers[t][i], height_method)
             for i in range(len(self.g.layers[t]))
             ]
            for t in range(self.g.num_steps)
        ]

        for layer in layers:
            for cluster in layer:
                cluster.build()

        clusters = [x for t in range(self.num_layers) for x in layers[t]]

        return clusters, layers

    ####################################################################################################################
    # -------------------------------------------- Helper Functions -------------------------------------------------- #
    ####################################################################################################################

    def pred(self, c: SizedConnectionCluster) -&gt; Optional[SizedConnectionCluster]:
        &#34;&#34;&#34;
        Returns the predecessor of this cluster (e.g. the cluster with rank-1)
        
        :param c: Cluster to find the predecessor of
        :return: SugiyamaCluster or None if no predecessor exists
        &#34;&#34;&#34;
        if c.rank == 0:
            return None
        return self.ordered[c.tc.layer][c.rank - 1]

    def succ(self, c: SizedConnectionCluster) -&gt; Optional[SizedConnectionCluster]:
        &#34;&#34;&#34;
        Returns the successor of this cluster (e.g. the cluster with rank+1)

        :param c: Cluster to find the successor of
        :return: SugiyamaCluster or None if no successor exists
        &#34;&#34;&#34;
        if c.rank == len(self.layers[c.tc.layer]) - 1:
            return None
        return self.ordered[c.tc.layer][c.rank + 1]

    @staticmethod
    def num_shared_neighbours(u, v):
        return len(set(v.incoming.keys()).intersection(set(u.incoming.keys()))) + len(
            set(v.outgoing.keys()).intersection(set(u.outgoing.keys())))

    ####################################################################################################################
    # --------------------------------------------- Order Functions -------------------------------------------------- #
    ####################################################################################################################

    def reset_order(self) -&gt; None:
        &#34;&#34;&#34;
        Reset the ordering properties of this graph and invalidate successive steps done with previous ordering.

        Clusters are first reset to the position in the original graph and then sorted by supercluster as a base case.
        &#34;&#34;&#34;
        self.ordered = [self.layers[t].copy() for t in range(self.num_layers)]
        for layer in self.ordered:
            for i, cluster in enumerate(layer):
                cluster.rank = i
        self.sort_by_supercluster()
        self.is_ordered = False
        self.is_aligned = False
        self.is_located = False

    def sort_by_supercluster(self) -&gt; None:
        &#34;&#34;&#34;
        Initialize the ranks of clusters to be near other clusters they are connected to

        This works by building superclusters with flood fill. In this case we start new superclusters with the
        highest unplaced cluster, instead of the leftmost one, because this balances much better
        &#34;&#34;&#34;
        pointers = [0] * self.num_layers
        seen = set()
        max_layer_size = max(map(len, self.layers))

        # traverse all clusters top to bottom instead of left to right
        for i in range(max_layer_size):
            for j in range(self.num_layers):
                if i &gt;= len(self.layers[j]) or i &lt; pointers[j]:
                    continue
                cluster = self.ordered[j][i]

                if cluster in seen:
                    continue
                seen.add(cluster)

                # Start new supercluster and fill it with a flood fill
                supercluster = []

                q = deque()
                q.append(cluster)
                while len(q) &gt; 0:
                    current = q.pop()

                    supercluster.append(current)
                    for nb in current.neighbours:
                        if nb not in seen:
                            q.append(nb)
                            seen.add(nb)

                for scluster in supercluster:
                    l = scluster.tc.layer
                    self.swap_clusters(scluster, self.ordered[l][pointers[l]])
                    pointers[l] += 1

    def set_order(self, barycenter_passes: int = 10) -&gt; None:
        &#34;&#34;&#34;
        Order the clusters in self.ordered with the barycenter method

        For each pass of the ordering, the barycenter method is applied once forward and once backward.
        After each pass the ordering is checked whether it changed w.r.t. the previous. All passes are independent
        So we can abort if they are the same.

        :param barycenter_passes: The maximum number of times to repeat the barycenter procedure
        &#34;&#34;&#34;
        # Make copy to compare if ordering has stabilized
        orders_tmp = [order.copy() for order in self.ordered]

        # Keep doing passes until the maximum number has been reached or the order does no longer change
        for i in range(barycenter_passes):
            # print(f&#34;Pass #{i}&#34;)
            self._barycenter()
            # self._barycenter()

            if orders_tmp == self.ordered:
                # print(&#34;Order stabilized&#34;)
                break

            orders_tmp = [order.copy() for order in self.ordered]

        self.is_ordered = True

    @staticmethod
    def _bary_rank_layer(layer: List[SizedConnectionCluster], max_inrank: int, max_outrank: int, alpha: float = 0.5) -&gt; None:
        &#34;&#34;&#34;
        Perform a barycenter sorting on this layer.

        For each cluster the weighted average rank of all incoming and outgoing connections is calculated.
        Then the ordering is decided by a combination of the inrank and outrank, determined by the total size of the
        connections and the alpha factor. If one side has many connections over the other, the side with many
        connections carries more weight. The alpha is the distribution factor, am alpha cose to 1 prioritizes incoming
        connections, an alpha close to 0 prioritizes outgoing. If the alpha is exactly 0 or 1 it is more difficult to
        separate to cluster with the same incoming or outgoing ocnnections.
        If a cluster has no incoming connections it will get the average of the in values of the previous and next
        cluster that do have a valid incoming value. If there is no successive cluster that has a valid value, they are
        given the maximum rank of the previous layer, plus 0.5. Same for the outgoing rank.

        :param layer: the layer to apply the procedure for
        :param max_inrank: The maximum rank in the previous layer
        :param max_outrank:  The maximum rank in the next layer
        :param alpha: Weight factor between 0 and 1 that balances incoming and outgoing
        &#34;&#34;&#34;
        for cluster in layer:
            cluster.update_cluster_ranks()
            # cluster.update_cluster_ranks_median()

        start_inr = 0
        prev_inr = 0.
        start_outr = 0
        prev_outr = 0.
        for i in range(len(layer)):

            if layer[i].inrank &gt;= 0.:
                for j in range(start_inr, i):
                    layer[j].inrank = (prev_inr + layer[i].inrank) / 2.
                start_inr = i + 1
                prev_inr = layer[i].inrank

            if layer[i].outrank &gt;= 0.:
                for j in range(start_outr, i):
                    layer[j].outrank = (prev_outr + layer[i].outrank) / 2.
                start_outr = i + 1
                prev_outr = layer[i].outrank

        for j in range(start_inr, len(layer)):
            layer[j].inrank = max_inrank + 0.5

        for j in range(start_outr, len(layer)):
            layer[j].outrank = max_outrank + 0.5

        total_outsize = sum(map(lambda x: x.outsize, layer))
        total_insize = sum(map(lambda x: x.insize, layer))
        layer.sort(key=lambda c: (c.inrank * total_insize * alpha + c.outrank * total_outsize * (1. - alpha)))

        # layer.sort(key=lambda c: (c.inr * alpha + c.outr * (1.-alpha)))  # simpler
        for i, cluster in enumerate(layer):
            cluster.rank = i

    def _barycenter(self) -&gt; None:
        &#34;&#34;&#34;
        Perform barycenter ordering once forward once backward

        Since each layer ordering depends on the previous layer, in the forward iteration layer 0 remains unchanged
        and in the backwards iteration the last layer is unchanged. So for a full ordering both forwards and backwards
        is needed.
        &#34;&#34;&#34;
        for i in range(self.num_layers):
            layer = self.ordered[i]
            prev_layer_size = (len(self.ordered[i - 1]) - 1) if i &gt; 0 else 0
            next_layer_size = (len(self.ordered[i + 1]) - 1) if i &lt; self.num_layers - 1 else 0

            self._bary_rank_layer(layer, prev_layer_size, next_layer_size, alpha=0.999)

        for i in range(self.num_layers - 2, -1, -1):
            layer = self.ordered[i]
            prev_layer_size = (len(self.ordered[i - 1]) - 1) if i &gt; 0 else 0
            next_layer_size = (len(self.ordered[i + 1]) - 1) if i &lt; self.num_layers - 1 else 0

            self._bary_rank_layer(layer, prev_layer_size, next_layer_size, alpha=0.001)

    def swap_clusters(self, cluster1: SizedConnectionCluster, cluster2: SizedConnectionCluster) -&gt; None:
        &#34;&#34;&#34;
        Swaps the ordered position/rank of two clusters clusters within the same layer

        :param cluster1:
        :param cluster2:
        &#34;&#34;&#34;
        order = self.ordered[cluster1.tc.layer]
        order[cluster1.rank], order[cluster2.rank] = order[cluster2.rank], order[cluster1.rank]
        cluster1.rank, cluster2.rank = cluster2.rank, cluster1.rank

    ####################################################################################################################
    # ---------------------------------------------- Crossing functions ---------------------------------------------- #
    ####################################################################################################################

    # IMPORTANT: These functions do not consider the size of the connection
    # Which is not really a problem, since one crossing with one larger line is not as bad as
    # many crossings with small lines.
    # The main ordering is done with barycenter, these functions can be used for smaller optimizations

    @staticmethod
    def _compare_ranked_lists(upper: List[int], lower: List[int]):
        &#34;&#34;&#34;
        Compare two ordered lists to see how many crossings they have

        Lists are assumed to be sorted low to high and contain ranks. A crossing is when a connection in the
        lower list is above a connection in the higher list.

        :param lower: List of ranks associated with the lower cluster.
        :param upper: List of ranks associated with the higher cluster
        &#34;&#34;&#34;
        j = i = crossings = 0

        while j &lt; len(lower) and i &lt; len(upper):
            if upper[i] &gt; lower[j]:
                j += 1
            elif upper[i] &lt;= lower[j]:
                crossings += j
                i += 1
        crossings += (len(upper) - i) * j

        return crossings

    @classmethod
    def get_num_crossings(cls, cluster1: SizedConnectionCluster, cluster2: SizedConnectionCluster):
        &#34;&#34;&#34;
        Count the number of crossings these 2 cluster have with each other.

        If cluster1 is upper (lower rank) than cluster2, it will return the current number of crossings.
        If cluster2 is upper, it will return the number of crossings as if they were swapped.

        :param cluster1: cluster that is assumed to be the upper cluster
        :param cluster2: cluster that is assumed to be the lower cluster
        &#34;&#34;&#34;
        sins_upper = sorted(map(lambda x: x[0].rank, cluster1.incoming.items()))
        sins_lower = sorted(map(lambda x: x[0].rank, cluster2.incoming.items()))
        souts_upper = sorted(map(lambda x: x[0].rank, cluster1.outgoing.items()))
        souts_lower = sorted(map(lambda x: x[0].rank, cluster2.outgoing.items()))
        return (cls._compare_ranked_lists(sins_upper, sins_lower)
                + cls._compare_ranked_lists(souts_upper, souts_lower))

    def crossing_diff_if_swapped(self, cluster1: SizedConnectionCluster, cluster2: SizedConnectionCluster) -&gt; int:
        &#34;&#34;&#34;
        Determine the relative difference in crossings if we were to swap the rank of these clusters.

        The clusters should be of the same layer.

        :param cluster1: One cluster
        :param cluster2: The other cluster
        :return: The relative difference. Negative indicates a decrease in crossings
        &#34;&#34;&#34;
        if cluster1.rank &gt; cluster2.rank:
            upper, lower = cluster2, cluster1
        else:
            upper, lower = cluster1, cluster2
        return self.get_num_crossings(lower, upper) - self.get_num_crossings(upper, lower)

    ####################################################################################################################
    # ------------------------------------------- Alignment Functions ------------------------------------------------ #
    ####################################################################################################################

    def reset_alignments(self) -&gt; None:
        &#34;&#34;&#34;
        Reset all alignment values and flag all subsequent steps to be out of date.
        &#34;&#34;&#34;
        for cluster in self.clusters:
            cluster.reset_alignment()
        self.is_aligned = False
        self.is_located = False

    def set_alignment(self, direction_flag=FORWARD, max_chain=-1, max_inout_diff=2., stairs_iterations=2) -&gt; None:
        &#34;&#34;&#34;
        Align clusters to be of the same chain to improved readability of the Graph.

        Clusters try to be chained with their median largest incoming connection. A chain is a sequence of clusters
        in successive layers that will all be placed at the same vertical coordinate. If two chains intersect
        at a point, the largest connection is given priority and the other chain is broken. If a cluster cannot
        align with its median largest cluster it will not try for other options.
        After chains are formed, the function will try to reduce staircasing by swapping clusters around.

        :param direction_flag: switch between aligning from left to right (forward) or right to left (backward)
        :param max_chain: Maximum length a chain is allowed, or -1 if a chain can be arbitrarily long
        :param max_inout_diff: Factor to prevent chains from forming when the difference between the largest incoming
        and largest outgoing connection is too big. A factor of two will prevent aligning the cluster if the largest
        outgoing connection is more than twice as large as its largest incoming. This prevents overenthousiastic
        alignments that make little sense. -1 for no limit
        :param stairs_iterations: The amount of iterations for the anti-staircase function.
        &#34;&#34;&#34;
        # Instead of passing on dozens of parameters, this checks if the user has already called the necessary functions
        # if not, it is called with the default parameters
        if not self.is_ordered:
            self.set_order()

        if direction_flag:
            layer_range = range(1, self.num_layers)
        else:
            layer_range = range(self.g.num_steps - 2, -1, -1)

        for layer in layer_range:
            r = -1

            for cluster in self.ordered[layer]:
                if (cluster.insize == 0 or
                        (
                                max_inout_diff &gt;= 0. and cluster.largest_outgoing / cluster.largest_incoming &gt; max_inout_diff)):
                    continue

                # Find cluster in previous layer this one wants to connect to and the weight of the connection
                wanted, connsize = cluster.largest_median_connection(direction=direction_flag)

                if wanted is not None and (max_chain &lt; 0 or wanted.root.chain_length &lt;= max_chain):

                    # Check if this connection contradicts another alignment
                    # priority to the new connection is only given if the weight is higher than all crossings
                    if wanted.rank &lt;= r:
                        if self.has_larger_crossings(wanted, r, connsize):
                            continue
                        self.remove_alignments(wanted, r)

                    wanted.align_with(cluster)
                    r = wanted.rank

        for _ in range(stairs_iterations):
            self.collapse_stairs_iteration()

        self.is_aligned = True

    def has_larger_crossings(self, start_cluster, until_rank, connection_size):
        &#34;&#34;&#34;
        Checks for crossing of at least a certain size until it is found or a certain rank is reached

        :param start_cluster: First cluster to check connections from. Should have a lower rank than until_rank
        :param until_rank: Continue up to and including the cluster of this rank.
        :param connection_size: Threshold for which to check.
        &#34;&#34;&#34;
        cluster = start_cluster
        while cluster is not None and cluster.rank &lt;= until_rank:
            if cluster.align != cluster.root and len(cluster.neighbours[cluster.align]) &gt; connection_size:
                return True
            cluster = self.succ(cluster)
        return False

    def remove_alignments(self, start_cluster: SizedConnectionCluster, until_rank: int):
        &#34;&#34;&#34;
        Removes all alignments of clusters from start_cluster until a certain rank is reached

        :param start_cluster: first cluster to remove alignment from. Should have a lower rank than until_rank
        :param until_rank: continue up to and including the cluster of this rank.
        &#34;&#34;&#34;
        cluster = start_cluster
        while cluster is not None and cluster.rank &lt;= until_rank:
            if cluster.align != cluster.root:  # cluster must not be an endpoint
                cluster.align.reset_alignment()
                cluster.reset_endpoint()
            cluster = self.succ(cluster)

    def adjacent_alignments(self, upper: SizedConnectionCluster, lower: SizedConnectionCluster):
        &#34;&#34;&#34;
        Checks whether two aligments are entirely adjacent or that there exists an alignment in between

        :param upper: cluster in the upper (lower rank) alignment
        :param lower: Cluster in the lower (higher rank) alignment
        :return: True if adjacent, False if there exists an alignment in between
        &#34;&#34;&#34;

        # Set base values
        uroot = upper.root
        lroot = lower.root
        upper = uroot
        lower = lroot

        # Align start layers, at most one while loop will actually run
        while upper.tc.layer &lt; lower.tc.layer:
            upper = upper.align

        while lower.tc.layer &lt; upper.tc.layer:
            lower = lower.align

        # Walk along alignment until either a cluster is found in between or the end of either alignment is reached
        while True:
            if not self.pred(lower) == upper:
                return False
            upper = upper.align
            lower = lower.align
            if upper == uroot or lower == lroot:
                break

        return True

    def crossing_diff_if_swapped_align(self, upper: SizedConnectionCluster, lower: SizedConnectionCluster):
        &#34;&#34;&#34;
        Count the amount of extra crossings this swap would cause. upper and lower should be in adjacent alignments

        Function works by swapping each element and summing the individual differences in crossings

        :param upper: cluster in the upper (lower rank) alignment
        :param lower: Cluster in the lower (higher rank) alignment
        &#34;&#34;&#34;
        uroot = upper.root
        lroot = lower.root
        cluster = lroot
        crossing_diff = 0
        length = 0
        while True:
            predecessor = self.pred(cluster)
            if predecessor is not None and predecessor.root == uroot:
                crossing_diff += self.crossing_diff_if_swapped(cluster, predecessor)
                length += 1
            cluster = cluster.align
            if cluster == lroot:
                break
        return crossing_diff - 2 * (length - 1)

    def swap_align(self, upper: SizedConnectionCluster, lower: SizedConnectionCluster):
        &#34;&#34;&#34;
        Count the amount of extra crossings this swap would cause. upper and lower should be in adjacent alignments

        Function works by swapping each element and summing the individual differences in crossings

        :param upper: cluster in the upper (lower rank) alignment
        :param lower: Cluster in the lower (higher rank) alignment
        &#34;&#34;&#34;
        uroot = upper.root
        lroot = lower.root
        cluster = lroot
        while True:
            predecessor = self.pred(cluster)
            if predecessor is not None and predecessor.root == uroot:
                self.swap_clusters(cluster, predecessor)

            cluster = cluster.align
            if cluster == lroot:
                break

    def collapse_stairs_iteration(self, minimum_want=3, allowed_extra_crossings=0):
        &#34;&#34;&#34;
        Mitigates the staircase effect on connected parts of the graph

        The goal is to move shorter chains closer to their desired position. Shorter chains have a better chance to
        fit tightly as opposed to longer chains.
        For every two adjacent alignments, it is always that either root is a predecessor or successor to a cluster
        in the other alignment. As such we only need to check the roots, but we have to check both the direction this
        alignment wants to go and the direction the predecessor alignment and successor alignment of the root want to go
        We first establish the desired direction of each alignment in its root. Then for each root we check 4 cases:
        case 1: this alignment wants to go up
        case 2: this alignment wants to go down
        case 3: the successor wants to go up
        case 4: the predecessor wants to go down
        These cases are mutually exclusive, even though case 1 and 4 cause the same swap, as do 2 and 3.
        Preference is given to case 1 and 2. It is a possibility that both case 3 and 4 are valid, but after execution
        of either case, the other will be obstructed, because the predecessor and successor change. Cases are looped
        until a stop condition is reached. In short for a swap to occur the following things must hold:
        a. in case 1 and 2, this chain must be shorter than the predecessor/successor. For case 3 and 4 this is inverted
        b. the shorter chain must move in its desired direction, updated after every step.
            A direction value between 2 and -2 (inclusive) is optimal and is treated as no desired direction.
        c. the alignments must be fully adjacent (ask me if this requirement is unclear)
        d. the swap may not increase the amount of crossings in the graph more than a certain amount (default: 0)
        &#34;&#34;&#34;
        for cluster in self.clusters:
            if cluster.root != cluster:
                continue
            cluster.update_wanted_direction()

        for cluster in self.clusters:
            if cluster.root != cluster:
                continue

            successor = self.succ(cluster)
            predecessor = self.pred(cluster)

            # Case 1
            while (cluster.wanted_direction &lt;= -minimum_want
                   and predecessor is not None and predecessor.root.chain_length &gt; cluster.chain_length
                   and self.adjacent_alignments(predecessor, cluster)
                   and self.crossing_diff_if_swapped_align(predecessor, cluster) &lt;= allowed_extra_crossings):
                self.swap_align(predecessor, cluster)
                predecessor.root.update_wanted_direction()
                cluster.update_wanted_direction()
                predecessor = self.pred(cluster)

            # Case 2
            while (cluster.wanted_direction &gt;= minimum_want
                   and successor is not None and successor.root.chain_length &gt; cluster.chain_length
                   and self.adjacent_alignments(cluster, successor)
                   and self.crossing_diff_if_swapped_align(cluster, successor) &lt;= allowed_extra_crossings):
                self.swap_align(cluster, successor)
                successor.root.update_wanted_direction()
                cluster.update_wanted_direction()
                successor = self.succ(cluster)

            # Case 3
            while (successor is not None and successor.root.chain_length &lt;= cluster.chain_length
                   and successor.root.wanted_direction &lt; -minimum_want
                   and self.adjacent_alignments(cluster, successor)
                   and self.crossing_diff_if_swapped_align(cluster, successor) &lt;= allowed_extra_crossings):
                self.swap_align(cluster, successor)
                successor.root.update_wanted_direction()
                cluster.update_wanted_direction()
                successor = self.succ(cluster)

            # Case 4
            while (predecessor is not None and predecessor.root.chain_length &lt; cluster.chain_length
                   and predecessor.root.wanted_direction &gt;= minimum_want
                   and self.adjacent_alignments(predecessor, cluster)
                   and self.crossing_diff_if_swapped_align(predecessor, cluster) &lt;= allowed_extra_crossings):
                self.swap_align(predecessor, cluster)
                predecessor.root.update_wanted_direction()
                cluster.update_wanted_direction()
                predecessor = self.pred(cluster)

    ####################################################################################################################
    # ------------------------------------------- Location Functions ------------------------------------------------- #
    ####################################################################################################################

    def set_locations(self, averaging_iterations=5) -&gt; None:
        &#34;&#34;&#34;
        Place the chains that have been identified and ordered.

        Chains are placed as compactly and high as possible initially. This can introduce unneccessary distances,
        so this value is treated as an upper bound. After the bounds have been established, chains will try to move as
        close to the average position of its connections outside itself below that bound, without moving past the
        chain below.

        :param averaging_iterations: The amount of times the averaging should be performed, as each iteration changes
        how low a cluster w.r.t. the position change of its successor.
        &#34;&#34;&#34;
        # Instead of passing on dozens of parameters, this checks if the user has already called the necessary functions
        # if not, it is called with the default parameters
        if not self.is_aligned:
            self.set_alignment()

        self.set_x_positions()

        for cluster in self.clusters:
            if cluster.root == cluster:
                self.place_block(cluster)

        self.set_y_positions()

        for _ in range(averaging_iterations):
            for cluster in self.clusters:
                cluster._y = -1.

            for cluster in self.clusters:
                if cluster.root == cluster:
                    self.avg_block(cluster)

            self.set_y_positions()

        self.check_locations()
        self.is_located = True

    def check_locations(self, excepting=True):
        &#34;&#34;&#34;
        Check whether the determined locations are consistent with the determined ordering

        :param excepting: Whether to raise an exception if the locations are inconsistent
        :return:
        &#34;&#34;&#34;
        for order in self.ordered:
            prev = -1
            for cluster in order:
                if cluster.y &lt;= prev:
                    if excepting:
                        raise UnorderedException(
                            f&#34;Locations are not in order of ranks: {cluster} is higher than {self.pred(cluster)}&#34;)
                    else:
                        print(f&#34;{cluster} is higher than {self.pred(cluster)}&#34;)
                prev = cluster.y

    def center_distance(self, u: SizedConnectionCluster, v: SizedConnectionCluster, non_connectedness_factor=1.):
        &#34;&#34;&#34;
        Calculate the distance between the centers of two cluster if they were to be adjacent

        :param u: Cluster
        :param v: Cluster
        :param non_connectedness_factor: Factor by which to increase the distance if the clusters do not share neighbors
        &#34;&#34;&#34;
        if non_connectedness_factor != 1. and self.num_shared_neighbours(u, v) == 0:
            return self.yseparation * non_connectedness_factor + (u.draw_size + v.draw_size) / 2.
        return self.yseparation + (u.draw_size + v.draw_size) / 2.

    def place_block(self, root):
        &#34;&#34;&#34;
        Place an aligned section by placing all blocks above it and then fitting it as high as possible

        :param root: Root of the alignment to place
        &#34;&#34;&#34;

        # If block was already placed, skip
        if root._y &lt; 0.:
            root._y = 0.
            cluster = root

            while True:
                if cluster.rank &gt; 0:
                    predecessor = self.pred(cluster)
                    self.place_block(predecessor.root)

                    root._y = max(root._y, predecessor.root._y + self.center_distance(predecessor, cluster))

                cluster = cluster.align
                if cluster == root:
                    break

    def avg_block(self, root):
        &#34;&#34;&#34;
        Place an aligned section by taking the average position

        place_block() puts all sections as high as they will go from top to bottom. This creates an upper bound on the
        alignment. Now from bottom to top we take the position this alignment would be placed based on average,
        bounded by the upper bound already calculated and the lower bound by the average of the block below.
        &#34;&#34;&#34;
        if root._y &lt; 0.:
            root._y = 0.
            cluster = root
            upper_bound = root.y
            lower_bound = float(&#39;inf&#39;)
            total = 0.
            ctr = 0

            while True:
                successor = self.succ(cluster)
                if successor is not None:
                    self.avg_block(successor.root)

                    lower_bound = min(lower_bound, successor.root._y - self.center_distance(cluster, successor))

                for k, value in cluster.outgoing.items():
                    if k == cluster.align:
                        continue
                    ctr += len(value)
                    total += k.y * len(value)

                for k, value in cluster.align.incoming.items():
                    if k == cluster:
                        continue
                    ctr += len(value)
                    total += k.y * len(value)

                cluster = cluster.align
                if cluster == root:
                    break
            if ctr == 0:
                root._y = upper_bound
            else:
                root._y = max(upper_bound, min(lower_bound, total / ctr))

    def set_x_positions(self):
        &#34;&#34;&#34;
        Update all x positions of all the clusters, as determined by their layer
        &#34;&#34;&#34;
        for cluster in self.clusters:
            cluster.x = self.xmargin + self.xseparation * cluster.tc.layer
        self.width = 2 * self.xmargin + self.xseparation * self.num_layers

    def set_y_positions(self) -&gt; None:
        &#34;&#34;&#34;
        Update all y positions of all the clusters, as determined by the algorithm. Also trim possible top margin.
        &#34;&#34;&#34;
        min_y = min(map(lambda x: x.root._y - x.draw_size / 2., self.clusters))
        for cluster in self.clusters:
            cluster.y = cluster.root._y + self.ymargin - min_y

        self.height = max(map(lambda x: x.root.y + x.draw_size / 2., self.clusters)) + 2*self.ymargin

    ####################################################################################################################
    # ------------------------------------------ Statistics Functions ------------------------------------------------ #
    ####################################################################################################################

    def streak_below(self, data: List[Number], num: Number) -&gt; int:
        &#34;&#34;&#34;
        Returns the longest streak that the data points are below some threshold.

        :param data: Data to analyse
        :param num: Threshold value
        :return: Largest count of consecutive points below the threshold
        &#34;&#34;&#34;
        longest = 0
        current = 0
        for d in data:
            if d &lt; num:
                current += 1
                if current &gt; longest:
                    longest = current
            else:
                current = 0
        return longest

    def streak_no_cross(self, data: List[Number], num: Number) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;
        Returns the longest streak of the datapoints not crossing the threshold in either direction and the total
        number of times the datapoints cross the threshold.

        :param data: Data to analyse
        :param num: Threshold value
        :return: Tuple of the longest streak and total amount of crossings
        &#34;&#34;&#34;
        longest = 1
        current = 1
        crossings = 0
        for i in range(len(data) - 1):
            if (data[i] &lt; num) == (data[i + 1] &lt; num):
                current += 1
                if current &gt; longest:
                    longest = current
            else:
                current = 1
                crossings += 1
        return longest, crossings

    ####################################################################################################################
    # ------------------------------------------- Drawing Functions -------------------------------------------------- #
    ####################################################################################################################

    def calculate_line_origins(self, source_cluster):
        &#34;&#34;&#34;
        Calculate the absolute origins for each line incident to this cluster

        This is calculated by sorting the other endpoints and &#34;empirically&#34; set them
        one after the other around the center.
        &#34;&#34;&#34;
        incomings = list(source_cluster.incoming.items())
        incomings.sort(key=lambda x: x[0].rank)
        outgoings = list(source_cluster.outgoing.items())
        outgoings.sort(key=lambda x: x[0].rank)

        # The key is a pair of (source, target)
        # The value is the y coordinate of where the endpoint in source should originate.
        pairs = {}

        # Space to leave between each line
        line_separation = self.line_width * self.line_spacing

        # We calculate around the center of the cluster, so this is the offset to start at
        half_in_width = (source_cluster.insize * self.line_width + line_separation * (len(incomings) - 1)) / 2.

        # source_cluster.y refers to the center of the cluster, so subtract half the width such that the center align
        cumulative = source_cluster.y - half_in_width
        for (target_cluster, members) in incomings:
            thickness = len(members) * self.line_width
            pairs[(source_cluster, target_cluster)] = cumulative + thickness / 2.
            cumulative += thickness + line_separation

        # We calculate around the center of the cluster, so this is the offset to start at
        half_out_width = (source_cluster.outsize * self.line_width + line_separation * (len(outgoings) - 1)) / 2.

        # source_cluster.y refers to the center of the cluster, so subtract half the width such that the center align
        cumulative = source_cluster.y - half_out_width
        for (target_cluster, members) in outgoings:
            thickness = len(members) * self.line_width
            pairs[(source_cluster, target_cluster)] = cumulative + thickness / 2.
            cumulative += thickness + line_separation

        return pairs

    def draw_line(self, source: SizedConnectionCluster, target: SizedConnectionCluster,
                  line_coordinates: dict, colormap: dict,
                  context: cairo.Context,
                  show_annotations=False):
        &#34;&#34;&#34;
        Draws the connection between source and target with label colors

        The line is divided in sections according to the labels of the nodes in this connection.
        For each unique label a line is drawn in the associated color with exact offset as to seem one single cohesive

        :param source: One endpoint of the line
        :param target: The other endpoint of the line
        :param line_coordinates: Dictionary with absolute coordinates of the endpoints
        :param colormap: Dictionary with label names and associated colors
        :param context: cairo context to draw this line on
        :param show_annotations: provides annotations when a line changes size significantly
        &#34;&#34;&#34;
        members = source.neighbours[target]
        num_members = len(members)
        thickness = num_members * self.line_width
        half_thickness = len(members) * self.line_width / 2.

        labels = Counter(map(lambda x: x.meta_string, members))
        labels = [(colormap.get(lbl, self.default_line_color), cnt / num_members) for (lbl, cnt) in
                  sorted(list(labels.items()))]

        y_source = line_coordinates[(source, target)]
        y_target = line_coordinates[(target, source)]
        context.save()
        context.rectangle(source.x, 0, target.x, self.height)
        context.clip()

        if len(labels) == 1:
            (r, g, b, a) = labels[0][0]
            context.set_source_rgba(r, g, b, a)
            context.set_line_width(thickness)
            context.move_to(source.x, y_source)
            context.curve_to(source.x + self.curve_offset, y_source,
                             target.x - self.curve_offset, y_target,
                             target.x, y_target)

            context.stroke()

        else:
            coloured_bezier(context,
                            (source.x, y_source),
                            (source.x + self.curve_offset, y_source),
                            (target.x - self.curve_offset, y_target),
                            (target.x, y_target),
                            labels,
                            thickness,
                            detail=min(100, max(4, int(abs(y_target - y_source) * self.line_width))))

        if show_annotations:
            # draw some annotatations of the bundle size
            context.set_source_rgb(0, 0, 0)
            context.select_font_face(&#34;Helvetica&#34;, cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_NORMAL)
            context.set_font_size(min(self.line_width * len(members), self.xseparation * 0.7))  # in user space units

            if len(members) &gt;= 1.5 * max(map(len, source.incoming.values()), default=0.):
                to_print = str(len(members))
                _, _, width, height, _, _ = context.text_extents(to_print)
                context.move_to(source.x + self.xseparation / 2 - width / 2,
                                (y_source + y_target) / 2 + height / 2)
                context.show_text(to_print)
                context.stroke()
        context.restore()

    def fade_cluster(self, context: cairo.Context, cluster: SizedConnectionCluster, colormap: Dict, direction):
        &#34;&#34;&#34;
        Draw a fading line into or from a certain cluster.

        :param context: cairo Context to draw on
        :param cluster: Cluster to use as source
        :param colormap: map of coloring for the names of the nodes in the cluster
        :param direction: True for a fade in, False for a fade out
        &#34;&#34;&#34;
        colors = [(colormap.get(lbl, self.default_line_color), cnt / len(cluster)) for (lbl, cnt) in
                  sorted(list(Counter(map(lambda x: x.meta_string, cluster.members)).items()))]
        if direction:
            coloured_bezier(context,
                            (cluster.x - self.xseparation / 3., cluster.y),
                            (cluster.x, cluster.y),
                            (cluster.x, cluster.y),
                            (cluster.x, cluster.y),
                            colors=colors, width=self.line_width * len(cluster), detail=4, fade=&#39;in&#39;)
        else:
            coloured_bezier(context,
                            (cluster.x, cluster.y),
                            (cluster.x, cluster.y),
                            (cluster.x, cluster.y),
                            (cluster.x + self.xseparation / 3., cluster.y),
                            colors=colors, width=self.line_width * len(cluster), detail=4, fade=&#39;out&#39;)

    def draw_timestamps(self, context: cairo.Context, timestamp_translator) -&gt; None:
        &#34;&#34;&#34;
        Separate surface that the timestamps are drawn onto.

        :param timestamp_translator: Object that converts a layer number to a layer identifier
        :return: Surface with drawn timestamps in the same offsets as the layers.
        &#34;&#34;&#34;

        context.set_source_rgb(0, 0, 0)
        context.select_font_face(&#34;Helvetica&#34;, cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_NORMAL)
        context.set_font_size(self.font_size)  # in user space units # self.xseparation * 0.6

        for t in range(self.num_layers):
            context.move_to(self.xmargin + t * self.xseparation, 0)
            context.line_to(self.xmargin + t * self.xseparation, self.xseparation * 0.2)

            to_print = str(t)
            if timestamp_translator:
                to_print = timestamp_translator[t]

            _, _, width, height, _, _ = context.text_extents(to_print)

            context.move_to(self.xmargin + t * self.xseparation + height / 2,
                            width + self.xseparation * 0.3)

            context.save()
            context.rotate(math.radians(270))  # angle in rad
            context.show_text(to_print)
            context.restore()

        context.stroke()

    def draw_connections(self, context: cairo.Context, colormap: dict, show_annotations: bool, fading: bool) -&gt; None:
        &#34;&#34;&#34;
        Returns a cairo surface with just the connections drawn onto them.

        :param colormap: dictionary that converts a node name to a color value
        :param show_annotations: Flag to show additional information per connection
        :param fading: Flag to also draw the fade in and out connections per cluster
        :return: cairo surface with connections
        &#34;&#34;&#34;

        line_coordinates = dict()  # k: (source, target), v: y-coordinate of endpoint in source.

        for cluster in self.clusters:
            line_coordinates.update(self.calculate_line_origins(cluster))

        if fading:
            for cluster in self.clusters:
                if cluster.insize == 0:
                    self.fade_cluster(context, cluster, colormap, direction=INCOMING)
                if cluster.outsize == 0:
                    self.fade_cluster(context, cluster, colormap, direction=OUTGOING)

        already_drawn = set()

        for (source, target) in line_coordinates.keys():
            if (target, source) in already_drawn:
                continue

            self.draw_line(source, target, line_coordinates, colormap, context, show_annotations=show_annotations)
            # self.draw_line_monochrome(source, target, line_coordinates, context)

            already_drawn.add((source, target))
            already_drawn.add((target, source))

    def draw_clusters(self, context: cairo.Context) -&gt; None:
        &#34;&#34;&#34;
        Returns a surface with all cluster drawn on them to be overlaid on the connection surface
        :return:
        &#34;&#34;&#34;
        (r, g, b, a) = self.default_cluster_color

        context.set_line_width(self.cluster_width)
        context.set_source_rgba(r, g, b, a)

        for cluster in self.clusters:
            cx, cy = cluster.pos()
            context.move_to(cx, cy - cluster.draw_size / 2.)
            context.line_to(cx, cy + cluster.draw_size / 2.)
            context.stroke()

    def draw_debug(self, context: cairo.Context, debug_info: Set[str]) -&gt; None:
        &#34;&#34;&#34;
        Surface that shows invasive debug information per connection or cluster.

        Accepts:
        &#39;swap_above&#39;: the relative difference in crossings if a cluster was to be swapped with the cluster above it
        &#39;ranks&#39;: Show the in and out rank information as calculated by the barycenter procedure.
        &#39;id&#39;: Show the layer and id of a cluster.

        :param debug_info: List of debug items to show.
        :return: cairo Surface with debug information
        &#34;&#34;&#34;
        context.set_source_rgb(0.2, 0.2, 0.2)
        context.select_font_face(&#34;Helvetica&#34;, cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_NORMAL)
        context.set_font_size(self.font_size * 0.2)

        for cluster in self.clusters:
            cx, cy = cluster.pos()
            if cluster.root == cluster:
                if &#34;swap_above&#34; in debug_info:
                    context.move_to(cx + self.xseparation * 0.1, cy)
                    context.show_text(
                        f&#34;{self.crossing_diff_if_swapped_align(self.pred(cluster), cluster) if self.pred(cluster) is not None else 0:.2f}&#34;)

            if &#34;ranks&#34; in debug_info:
                context.move_to(cx + self.xseparation * 0.1, cy)
                context.show_text(f&#34;{cluster.outrank:.2f}&#34;)
                context.move_to(cx - self.xseparation * 0.3, cy)
                context.show_text(f&#34;{cluster.inrank:.2f}&#34;)

            if &#34;id&#34; in debug_info:
                context.move_to(cx + self.xseparation * 0.1, cy)
                context.show_text(f&#34;{cluster.tc.id}&#34;)
                context.move_to(cx - self.xseparation * 0.3, cy)
                context.show_text(f&#34;{cluster.tc.layer}&#34;)

    def draw_stats(self, context: cairo.Context, data: Collection[str], maxheight: int = 200) -&gt; None:
        &#34;&#34;&#34;
        Returns a recording surface to be played back with statistics about the graph.

        Currently accepted statistic strings are &#34;in_out_difference&#34;, &#34;layer_num_clusters&#34;, &#34;layer_num_members&#34;,
        &#34;homogeneity&#34;, &#34;homogeneity_diff&#34;. See for explanations the respective functions in TimeGraph.
        Per statistic the height of the drawing is one third of the graph height or maxheight, whichever is lower.

        :param maxheight: Maximum height in points of per statistic
        :param data: Iterable of strings of the statistics to show (in order)
        :return: cairo recording of statistics
        &#34;&#34;&#34;
        h = min(self.height / 3, maxheight)

        marg = 0.1  # Margin around the drawing and in between different stats, in percent of h.

        for i, name in enumerate(data):

            if name == &#34;in_out_difference&#34;:
                d = self.g.layer_in_out_diff()
            elif name == &#34;layer_num_clusters&#34;:
                d = self.g.layer_num_clusters()
            elif name == &#34;layer_num_members&#34;:
                d = self.g.layer_num_members()
            elif name == &#34;homogeneity&#34;:
                d = self.g.relative_continuity()
            elif name == &#34;homogeneity_diff&#34;:
                d = self.g.relative_continuity_diff()
            else:
                print(f&#34;Name {name} not found!&#34;)
                continue

            maxval = max(d)
            scale = (h * (1. - 2 * marg)) / maxval  # Scale of the graph.

            context.set_line_width(h/100)

            # Draw base axes
            context.set_source_rgba(0, 0, 0, 1)
            context.move_to(self.xmargin * 0.95, (i + marg) * h)
            context.line_to(self.xmargin * 0.9, (i + marg) * h)
            context.line_to(self.xmargin * 0.9, (i + 1. - marg) * h)
            context.line_to(self.width - self.xmargin, (i + 1. - marg) * h)
            context.stroke()

            # Show top value (bottom is always 0)
            text_to_show = f&#34;{maxval:.2f}&#34;
            context.select_font_face(&#34;Helvetica&#34;, cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_NORMAL)
            context.set_font_size(min(self.font_size * 0.4, h / 10))
            _, _, tw, th, _, _ = context.text_extents(text_to_show)
            context.move_to(self.xmargin * 0.85 - tw, (i + marg) * h + th)
            context.show_text(text_to_show)

            # Draw line of average
            avg = sum(d) / len(d)
            context.set_source_rgba(0, 1, 0, 1)
            context.move_to(self.xmargin, (i + marg) * h + (maxval - avg) * scale)
            context.line_to(self.width - self.xmargin, (i + marg) * h + (maxval - avg) * scale)
            context.stroke()

            # Draw data
            context.set_source_rgba(0, 0, 1, 1)
            context.move_to(self.xmargin, (i + marg) * h + (maxval - d[0]) * scale)
            for j in range(1, len(d)):
                context.line_to(self.xmargin + j * self.xseparation, (i + marg) * h + (maxval - d[j]) * scale)

            context.stroke()

            # Show additional information in text
            streak, crossings = self.streak_no_cross(d, avg)
            text_to_show = f&#34;{name}: avg ({avg:.3f}), streak ({streak}), crossings ({crossings}), cross_percent ({(crossings / len(d)):2f})&#34;

            context.set_font_size(min(self.font_size * 0.5, h / 8))
            _, _, tw, th, _, _ = context.text_extents(text_to_show)
            context.move_to(0.3 * self.xseparation + self.xmargin, (i + marg) * h + th)
            context.show_text(text_to_show)

    def get_timestamp_height(self, timestamp_translator):
        tmpsurf = cairo.RecordingSurface(cairo.CONTENT_COLOR_ALPHA, None)
        context = cairo.Context(tmpsurf)
        context.select_font_face(&#34;Helvetica&#34;, cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_NORMAL)
        context.set_font_size(self.font_size)

        h = max([context.text_extents(timestamp_translator.get(t, str(t)))[2] for t in range(self.num_layers)]) + 0.3*self.xseparation
        tmpsurf.finish()
        return h

    def get_stat_height(self, stat_info, maxheight):
        return min(self.height / 3, maxheight) * len(stat_info)

    def draw_graph(self, filename: str = &#34;output/example.svg&#34;,
                   colormap=None,
                   show_timestamps=True, timestamp_translator=None,
                   show_annotations=False, debug_info=None, stats_info=None,
                   fading=False, scale=1.):

        if colormap is None:
            colormap = dict()

        if timestamp_translator is None:
            timestamp_translator = dict()

        # Instead of passing on dozens of parameters, this checks if the user has already called the necessary functions
        # if not, it is called with the default parameters
        if not self.is_located:
            self.set_locations()

        canvaswidth = self.width
        canvasheight = self.height
        if show_timestamps:
            timeheight = self.get_timestamp_height(timestamp_translator) + self.ymargin
            canvasheight += timeheight

        if stats_info is not None:
            canvasheight += self.get_stat_height(stats_info, 200) + self.ymargin

        surface = cairo.SVGSurface(filename, canvaswidth * scale, canvasheight * scale)
        context = cairo.Context(surface)
        context.scale(scale, scale)

        self.draw_connections(context, colormap, show_annotations, fading)
        self.draw_clusters(context)
        if debug_info is not None:
            self.draw_debug(context, debug_info)
        context.translate(0, self.height)
        # offset = self.height + 2*self.ymargin
        if show_timestamps:
            self.draw_timestamps(context, timestamp_translator)
            context.translate(0, timeheight)
        if stats_info is not None:
            self.draw_stats(context, stats_info)

        surface.flush()
        surface.finish()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tgv.layout.NotEndpointException"><code class="flex name class">
<span>class <span class="ident">NotEndpointException</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NotEndpointException(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="tgv.layout.NotRootException"><code class="flex name class">
<span>class <span class="ident">NotRootException</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NotRootException(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="tgv.layout.SizedConnectionCluster"><code class="flex name class">
<span>class <span class="ident">SizedConnectionCluster</span></span>
<span>(</span><span>tc:TimeCluster, height_method)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SizedConnectionCluster:
    def __init__(self, tc: TimeCluster, height_method):
        # Link to original TimeCluster and vice versa
        self.tc = tc
        tc.sc = self

        # Connection properties
        self.incoming = dict()  # Filled by build(), k is SugiyamaCluster, v is set of TimeNodes
        self.outgoing = dict()  # Filled by build(), k is SugiyamaCluster, v is set of TimeNodes
        self.neighbours = dict()  # Filled by build(), k is SugiyamaCluster, v is set of TimeNodes

        self.insize = 0  # Filled by build(), number of incoming connections
        self.outsize = 0  # Filled by build(), number of outgoing connections

        self.largest_incoming = 0  # Filled by build(), size of the largest incoming connection
        self.largest_outgoing = 0  # Filled by build(), size of the largest outgoing connection

        self.members = self.tc.members  # Set of TimeNodes in this cluster

        # Order properties
        self.rank = -1
        self.inrank = -1
        self.outrank = -1
        self.wanted_direction = 0

        # Alignment properties
        self.root = self
        self.align = self
        self.chain_length = 1

        # Location properties
        self.x = -1
        self.y = -1
        self._y = -1  # storage value if self.y should not be changed immediately

        # Drawing properties
        self.draw_size = self.draw_height(height_method)

    def draw_height(self, method: str) -&gt; float:
        &#34;&#34;&#34;
        Determine vertical size of this cluster depending on its size

        :param method: The function to apply to the member size. Accepts &#39;linear&#39;, &#39;sqrt&#39;, &#39;log&#39; or &#39;constant&#39;
        :return: Size of this cluster
        &#34;&#34;&#34;
        if method == &#39;linear&#39;:
            return len(self.members)
        elif method == &#39;sqrt&#39;:
            return math.sqrt(len(self.members))
        elif method == &#39;log&#39;:
            return math.log(len(self.members))
        elif method == &#39;constant&#39;:
            return 1.
        else:
            return 0.

    def build(self) -&gt; None:
        &#34;&#34;&#34;
        Builds the neighbour set and related data from the base TimeCluster

        &#34;&#34;&#34;
        for c, connection_nodes in self.tc.incoming.items():
            self.incoming[c.sc] = connection_nodes

        for c, connection_nodes in self.tc.outgoing.items():
            self.outgoing[c.sc] = connection_nodes

        self.insize = self.tc.insize
        self.outsize = self.tc.outsize
        self.neighbours = {**self.incoming, **self.outgoing}
        self.largest_incoming = max(map(len, self.incoming.values()), default=0)
        self.largest_outgoing = max(map(len, self.outgoing.values()), default=0)

    def update_cluster_ranks(self) -&gt; Tuple[float, float]:
        &#34;&#34;&#34;
        Update the rank information of this cluster

        Rank information is determined by the average rank of the incoming and outgoing connections. Since ranks can
        vary wildly between layers, inrank and outrank can not be compared to each other or this clusters own rank.

        :return: The average incoming rank and the average outgoing rank, or -1 for either if it has none on that side
        &#34;&#34;&#34;
        if self.insize &gt; 0:
            inrank = sum([nb.rank * len(conn) for nb, conn in self.incoming.items()]) / self.insize
        else:
            inrank = -1

        if self.outsize &gt; 0:
            outrank = sum([n.rank * len(l) for n, l in self.outgoing.items()]) / self.outsize
        else:
            outrank = -1

        self.inrank = inrank
        self.outrank = outrank
        return inrank, outrank

    def update_cluster_ranks_median(self) -&gt; Tuple[float, float]:
        &#34;&#34;&#34;
        Update the rank information of this cluster using median instead of average

        Rank information is determined by the median rank of the incoming and outgoing connections. Since ranks can
        vary wildly between layers, inrank and outrank can not be compared to each other or this clusters own rank.

        :return: The median incoming rank and the median outgoing rank
        &#34;&#34;&#34;
        inc = list(self.incoming.items())
        out = list(self.outgoing.items())

        self.inrank, self.outrank = self.weighted_median_rank(inc), self.weighted_median_rank(out)
        return self.inrank, self.outrank

    @staticmethod
    def weighted_median_rank(nbs: List[(SizedConnectionCluster, Set)]) -&gt; float:
        &#34;&#34;&#34;
        Of a list of neighbours, return the median ranked neighbour adjusted for integer weighted connections

        Instead of taking the median connection, this function finds the connection that the median ranked node belongs to
        :param nbs: list of neighbours and connection members
        :return: The rank of the cluster of which the median node is connected
        &#34;&#34;&#34;
        if len(nbs) == 0:
            return -1

        nbs.sort(key=lambda x: x[0].rank)
        inc_total = sum(map(lambda x: len(x[1]), nbs))
        ptr = 0
        inc_sum = 0.
        while inc_sum &lt; inc_total / 2.:
            inc_sum += len(nbs[ptr][1])
            ptr += 1
        if inc_total % 2 == 0 and inc_sum == inc_total // 2:
            med = (nbs[ptr][0].rank + nbs[ptr - 1][0].rank) / 2.
        else:
            med = nbs[ptr - 1][0].rank
        return med

    def reset_alignment(self) -&gt; None:
        &#34;&#34;&#34;
        Reset the values used in determining alignment to their default values
        &#34;&#34;&#34;
        self.root = self
        self.align = self
        self.chain_length = 1

    def reset_endpoint(self) -&gt; None:
        &#34;&#34;&#34;
        If this cluster is the second to last of a chain, make it the last in the chain
        The cluster removed from the chain should be reset separately
        &#34;&#34;&#34;
        if self.align == self.root or self.align.align != self.align.root:
            return
        self.align = self.root
        self.root.chain_length = max(1, self.root.chain_length - 1)

    def largest_median_connection(self, lower=True, direction=INCOMING) -&gt; (SizedConnectionCluster, int):
        &#34;&#34;&#34;
        Returns the cluster with the largest connection to this one.

        If multiple candidates with equal connection weight exist, returns the lower median in ordering

        :param self: Cluster to find the median median of
        :param lower: Flag to take either the upper or lower median if even amount
        :param direction: Flag for direction. True is incoming, False is outgoing
        :return: The cluster and the weight of the connection
        &#34;&#34;&#34;

        if direction:  # is INCOMING
            connections = list(self.incoming.items())
        else:  # is OUTGOING
            connections = list(self.outgoing.items())

        if len(connections) == 0:
            return None, 0

        connections.sort(key=lambda x: (len(x[1]), x[0].rank), reverse=True)
        ptr = 0
        while ptr &lt; len(connections) and len(connections[ptr][1]) == len(connections[0][1]):
            ptr += 1

        brother = connections[(ptr - (1 if lower else 0)) // 2][0]
        connsize = len(connections[0][1])
        return brother, connsize

    def align_with(self, next_cluster: SizedConnectionCluster) -&gt; None:
        &#34;&#34;&#34;
        puts next_cluster as the next link in this chain, if self is an endpoint

        :param next_cluster: The cluster to align with current chain
        &#34;&#34;&#34;
        if self.align != self.root:
            raise NotEndpointException(
                f&#34;Can only align if self is an endpoint, but {self} is aligned with {self.align}&#34;)
        self.align = next_cluster
        next_cluster.root = self.root
        next_cluster.align = self.root
        self.root.chain_length += 1

    def update_wanted_direction(self) -&gt; int:
        &#34;&#34;&#34;
        Function to calculate which direction an alignment would like to move in depending on the ranks of its connections

        :return: The direction (positive is downwards, negative is upwards) and strength of the direction
        &#34;&#34;&#34;
        if self.root != self:
            raise NotRootException(&#34;You can only call wanted_direction on an alignment root.&#34;)

        # l holds the alignment for quick access in all directions
        l = []

        cluster = self
        while True:
            l.append(cluster)
            if cluster.align == self:
                break
            cluster = cluster.align

        total = 0
        for i in range(1, len(l)):
            cluster = l[i]
            # Compare incoming connections to the rank of the previous in the alignment
            for k, v in l[i].incoming.items():
                total += len(v) * (k.rank - l[i - 1].rank)

        for i in range(0, len(l) - 1):
            # Compare outgoing connections to the rank of the next in the alignment
            for k, v in l[i].outgoing.items():
                total += len(v) * (k.rank - l[i + 1].rank)

        # The first and last elements of l are not aligned further for a reason
        # So we have to factor in the direction of where this alignment would have liked to go
        left, _ = l[0].largest_median_connection(direction=INCOMING)
        if left is not None and left.align.tc.layer == l[0].tc.layer:
            total += left.align.rank - l[0].rank

        right, _ = l[-1].largest_median_connection(direction=OUTGOING)
        if right is not None and right.root.tc.layer &lt;= l[-1].tc.layer:
            prev = right.root
            while prev.align != right:
                prev = prev.align
            total += prev.rank - l[-1].rank

        self.wanted_direction = total
        return total

    def pos(self) -&gt; Tuple[float, float]:
        &#34;&#34;&#34;
        Returns the current x and y coordinate of this cluster. This should be treated as the center of this cluster.

        :return: tuple of x and y coordinate
        &#34;&#34;&#34;
        return self.x, self.y

    def __str__(self):
        return f&#34;SugiyamaCluster {str((self.tc.layer, self.tc.id))}/{self.rank} at {self.y}&#34;

    def __len__(self):
        return len(self.members)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="tgv.layout.SizedConnectionCluster.weighted_median_rank"><code class="name flex">
<span>def <span class="ident">weighted_median_rank</span></span>(<span>nbs:List[<a title="tgv.layout.SizedConnectionCluster" href="#tgv.layout.SizedConnectionCluster">SizedConnectionCluster</a>,Set]) >float</span>
</code></dt>
<dd>
<div class="desc"><p>Of a list of neighbours, return the median ranked neighbour adjusted for integer weighted connections</p>
<p>Instead of taking the median connection, this function finds the connection that the median ranked node belongs to
:param nbs: list of neighbours and connection members
:return: The rank of the cluster of which the median node is connected</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def weighted_median_rank(nbs: List[(SizedConnectionCluster, Set)]) -&gt; float:
    &#34;&#34;&#34;
    Of a list of neighbours, return the median ranked neighbour adjusted for integer weighted connections

    Instead of taking the median connection, this function finds the connection that the median ranked node belongs to
    :param nbs: list of neighbours and connection members
    :return: The rank of the cluster of which the median node is connected
    &#34;&#34;&#34;
    if len(nbs) == 0:
        return -1

    nbs.sort(key=lambda x: x[0].rank)
    inc_total = sum(map(lambda x: len(x[1]), nbs))
    ptr = 0
    inc_sum = 0.
    while inc_sum &lt; inc_total / 2.:
        inc_sum += len(nbs[ptr][1])
        ptr += 1
    if inc_total % 2 == 0 and inc_sum == inc_total // 2:
        med = (nbs[ptr][0].rank + nbs[ptr - 1][0].rank) / 2.
    else:
        med = nbs[ptr - 1][0].rank
    return med</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tgv.layout.SizedConnectionCluster.align_with"><code class="name flex">
<span>def <span class="ident">align_with</span></span>(<span>self, next_cluster:<a title="tgv.layout.SizedConnectionCluster" href="#tgv.layout.SizedConnectionCluster">SizedConnectionCluster</a>) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>puts next_cluster as the next link in this chain, if self is an endpoint</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>next_cluster</code></strong></dt>
<dd><p>The cluster to align with current chain</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def align_with(self, next_cluster: SizedConnectionCluster) -&gt; None:
    &#34;&#34;&#34;
    puts next_cluster as the next link in this chain, if self is an endpoint

    :param next_cluster: The cluster to align with current chain
    &#34;&#34;&#34;
    if self.align != self.root:
        raise NotEndpointException(
            f&#34;Can only align if self is an endpoint, but {self} is aligned with {self.align}&#34;)
    self.align = next_cluster
    next_cluster.root = self.root
    next_cluster.align = self.root
    self.root.chain_length += 1</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionCluster.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>self) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Builds the neighbour set and related data from the base TimeCluster</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build(self) -&gt; None:
    &#34;&#34;&#34;
    Builds the neighbour set and related data from the base TimeCluster

    &#34;&#34;&#34;
    for c, connection_nodes in self.tc.incoming.items():
        self.incoming[c.sc] = connection_nodes

    for c, connection_nodes in self.tc.outgoing.items():
        self.outgoing[c.sc] = connection_nodes

    self.insize = self.tc.insize
    self.outsize = self.tc.outsize
    self.neighbours = {**self.incoming, **self.outgoing}
    self.largest_incoming = max(map(len, self.incoming.values()), default=0)
    self.largest_outgoing = max(map(len, self.outgoing.values()), default=0)</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionCluster.draw_height"><code class="name flex">
<span>def <span class="ident">draw_height</span></span>(<span>self, method:str) >float</span>
</code></dt>
<dd>
<div class="desc"><p>Determine vertical size of this cluster depending on its size</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>method</code></strong></dt>
<dd><p>The function to apply to the member size. Accepts 'linear', 'sqrt', 'log' or 'constant'</p></dd>
</dl>
<h2 id="returns">Returns:</h2>
<dl>
<dd><p>Size of this cluster</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_height(self, method: str) -&gt; float:
    &#34;&#34;&#34;
    Determine vertical size of this cluster depending on its size

    :param method: The function to apply to the member size. Accepts &#39;linear&#39;, &#39;sqrt&#39;, &#39;log&#39; or &#39;constant&#39;
    :return: Size of this cluster
    &#34;&#34;&#34;
    if method == &#39;linear&#39;:
        return len(self.members)
    elif method == &#39;sqrt&#39;:
        return math.sqrt(len(self.members))
    elif method == &#39;log&#39;:
        return math.log(len(self.members))
    elif method == &#39;constant&#39;:
        return 1.
    else:
        return 0.</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionCluster.largest_median_connection"><code class="name flex">
<span>def <span class="ident">largest_median_connection</span></span>(<span>self, lower=True, direction=True) >(<a title="tgv.layout.SizedConnectionCluster" href="#tgv.layout.SizedConnectionCluster">SizedConnectionCluster</a>,int)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the cluster with the largest connection to this one.</p>
<p>If multiple candidates with equal connection weight exist, returns the lower median in ordering</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>self</code></strong></dt>
<dd><p>Cluster to find the median median of</p></dd>
<dt><strong><code>lower</code></strong></dt>
<dd><p>Flag to take either the upper or lower median if even amount</p></dd>
<dt><strong><code>direction</code></strong></dt>
<dd><p>Flag for direction. True is incoming, False is outgoing</p></dd>
</dl>
<h2 id="returns">Returns:</h2>
<dl>
<dd><p>The cluster and the weight of the connection</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def largest_median_connection(self, lower=True, direction=INCOMING) -&gt; (SizedConnectionCluster, int):
    &#34;&#34;&#34;
    Returns the cluster with the largest connection to this one.

    If multiple candidates with equal connection weight exist, returns the lower median in ordering

    :param self: Cluster to find the median median of
    :param lower: Flag to take either the upper or lower median if even amount
    :param direction: Flag for direction. True is incoming, False is outgoing
    :return: The cluster and the weight of the connection
    &#34;&#34;&#34;

    if direction:  # is INCOMING
        connections = list(self.incoming.items())
    else:  # is OUTGOING
        connections = list(self.outgoing.items())

    if len(connections) == 0:
        return None, 0

    connections.sort(key=lambda x: (len(x[1]), x[0].rank), reverse=True)
    ptr = 0
    while ptr &lt; len(connections) and len(connections[ptr][1]) == len(connections[0][1]):
        ptr += 1

    brother = connections[(ptr - (1 if lower else 0)) // 2][0]
    connsize = len(connections[0][1])
    return brother, connsize</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionCluster.pos"><code class="name flex">
<span>def <span class="ident">pos</span></span>(<span>self) >Tuple[float,float]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current x and y coordinate of this cluster. This should be treated as the center of this cluster.</p>
<h2 id="returns">Returns:</h2>
<dl>
<dd><p>tuple of x and y coordinate</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pos(self) -&gt; Tuple[float, float]:
    &#34;&#34;&#34;
    Returns the current x and y coordinate of this cluster. This should be treated as the center of this cluster.

    :return: tuple of x and y coordinate
    &#34;&#34;&#34;
    return self.x, self.y</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionCluster.reset_alignment"><code class="name flex">
<span>def <span class="ident">reset_alignment</span></span>(<span>self) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Reset the values used in determining alignment to their default values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_alignment(self) -&gt; None:
    &#34;&#34;&#34;
    Reset the values used in determining alignment to their default values
    &#34;&#34;&#34;
    self.root = self
    self.align = self
    self.chain_length = 1</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionCluster.reset_endpoint"><code class="name flex">
<span>def <span class="ident">reset_endpoint</span></span>(<span>self) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>If this cluster is the second to last of a chain, make it the last in the chain
The cluster removed from the chain should be reset separately</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_endpoint(self) -&gt; None:
    &#34;&#34;&#34;
    If this cluster is the second to last of a chain, make it the last in the chain
    The cluster removed from the chain should be reset separately
    &#34;&#34;&#34;
    if self.align == self.root or self.align.align != self.align.root:
        return
    self.align = self.root
    self.root.chain_length = max(1, self.root.chain_length - 1)</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionCluster.update_cluster_ranks"><code class="name flex">
<span>def <span class="ident">update_cluster_ranks</span></span>(<span>self) >Tuple[float,float]</span>
</code></dt>
<dd>
<div class="desc"><p>Update the rank information of this cluster</p>
<p>Rank information is determined by the average rank of the incoming and outgoing connections. Since ranks can
vary wildly between layers, inrank and outrank can not be compared to each other or this clusters own rank.</p>
<h2 id="returns">Returns:</h2>
<dl>
<dd><p>The average incoming rank and the average outgoing rank, or -1 for either if it has none on that side</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_cluster_ranks(self) -&gt; Tuple[float, float]:
    &#34;&#34;&#34;
    Update the rank information of this cluster

    Rank information is determined by the average rank of the incoming and outgoing connections. Since ranks can
    vary wildly between layers, inrank and outrank can not be compared to each other or this clusters own rank.

    :return: The average incoming rank and the average outgoing rank, or -1 for either if it has none on that side
    &#34;&#34;&#34;
    if self.insize &gt; 0:
        inrank = sum([nb.rank * len(conn) for nb, conn in self.incoming.items()]) / self.insize
    else:
        inrank = -1

    if self.outsize &gt; 0:
        outrank = sum([n.rank * len(l) for n, l in self.outgoing.items()]) / self.outsize
    else:
        outrank = -1

    self.inrank = inrank
    self.outrank = outrank
    return inrank, outrank</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionCluster.update_cluster_ranks_median"><code class="name flex">
<span>def <span class="ident">update_cluster_ranks_median</span></span>(<span>self) >Tuple[float,float]</span>
</code></dt>
<dd>
<div class="desc"><p>Update the rank information of this cluster using median instead of average</p>
<p>Rank information is determined by the median rank of the incoming and outgoing connections. Since ranks can
vary wildly between layers, inrank and outrank can not be compared to each other or this clusters own rank.</p>
<h2 id="returns">Returns:</h2>
<dl>
<dd><p>The median incoming rank and the median outgoing rank</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_cluster_ranks_median(self) -&gt; Tuple[float, float]:
    &#34;&#34;&#34;
    Update the rank information of this cluster using median instead of average

    Rank information is determined by the median rank of the incoming and outgoing connections. Since ranks can
    vary wildly between layers, inrank and outrank can not be compared to each other or this clusters own rank.

    :return: The median incoming rank and the median outgoing rank
    &#34;&#34;&#34;
    inc = list(self.incoming.items())
    out = list(self.outgoing.items())

    self.inrank, self.outrank = self.weighted_median_rank(inc), self.weighted_median_rank(out)
    return self.inrank, self.outrank</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionCluster.update_wanted_direction"><code class="name flex">
<span>def <span class="ident">update_wanted_direction</span></span>(<span>self) >int</span>
</code></dt>
<dd>
<div class="desc"><p>Function to calculate which direction an alignment would like to move in depending on the ranks of its connections</p>
<h2 id="returns">Returns:</h2>
<dl>
<dd><p>The direction (positive is downwards, negative is upwards) and strength of the direction</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_wanted_direction(self) -&gt; int:
    &#34;&#34;&#34;
    Function to calculate which direction an alignment would like to move in depending on the ranks of its connections

    :return: The direction (positive is downwards, negative is upwards) and strength of the direction
    &#34;&#34;&#34;
    if self.root != self:
        raise NotRootException(&#34;You can only call wanted_direction on an alignment root.&#34;)

    # l holds the alignment for quick access in all directions
    l = []

    cluster = self
    while True:
        l.append(cluster)
        if cluster.align == self:
            break
        cluster = cluster.align

    total = 0
    for i in range(1, len(l)):
        cluster = l[i]
        # Compare incoming connections to the rank of the previous in the alignment
        for k, v in l[i].incoming.items():
            total += len(v) * (k.rank - l[i - 1].rank)

    for i in range(0, len(l) - 1):
        # Compare outgoing connections to the rank of the next in the alignment
        for k, v in l[i].outgoing.items():
            total += len(v) * (k.rank - l[i + 1].rank)

    # The first and last elements of l are not aligned further for a reason
    # So we have to factor in the direction of where this alignment would have liked to go
    left, _ = l[0].largest_median_connection(direction=INCOMING)
    if left is not None and left.align.tc.layer == l[0].tc.layer:
        total += left.align.rank - l[0].rank

    right, _ = l[-1].largest_median_connection(direction=OUTGOING)
    if right is not None and right.root.tc.layer &lt;= l[-1].tc.layer:
        prev = right.root
        while prev.align != right:
            prev = prev.align
        total += prev.rank - l[-1].rank

    self.wanted_direction = total
    return total</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tgv.layout.SizedConnectionLayout"><code class="flex name class">
<span>class <span class="ident">SizedConnectionLayout</span></span>
<span>(</span><span>g:TimeGraph, line_width=-1.0, line_spacing=0.0, line_curviness=0.3, horizontal_density=2.0, vertical_density=1.0, cluster_width=-1, cluster_height_method='linear', font_size=-1, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SizedConnectionLayout:

    ####################################################################################################################
    # -------------------------------------------- init Functions ---------------------------------------------------- #
    ####################################################################################################################

    def __init__(self, g: TimeGraph,
                 line_width=-1., line_spacing=0.0,
                 line_curviness=0.3,
                 horizontal_density=2., vertical_density=1.,
                 cluster_width=-1,
                 cluster_height_method=&#39;linear&#39;,
                 font_size=-1,
                 verbose=False):

        # Set basic information from the time graph
        self.g = g
        self.num_layers = self.g.num_steps

        # Set different collection objects
        self.clusters, self.layers = self.build_clusters(cluster_height_method)
        self.ordered = []  # Filled by reset_order()
        self.reset_order()

        # Set flags
        self.is_ordered = False
        self.is_aligned = False
        self.is_located = False

        # General info
        max_cluster = max(self.clusters, key=len)
        self.max_cluster_height = max_cluster.draw_size
        self.max_cluster_size = len(max_cluster)  # Amount of elements in cluster
        self.max_bundle_size = max(
            [max(map(len, cluster.neighbours.values())) for cluster in self.clusters])  # Amount elements in connection
        self.max_num_connection = max(
            map(lambda x: len(x.incoming), self.clusters))  # Amount of connections on one side of a cluster

        # Location settings
        # 1 point = 0.352 mm, or 3 points = 1 mm
        self.xseparation_frac = horizontal_density  # (fraction) from user
        self.yseparation_frac = vertical_density  # (fraction) from user
        self.line_spacing = line_spacing  # (fraction) from user; relative to line_width
        self.line_width = line_width if line_width &gt;= 0. else self.auto_line_width()  # (in points) from user
        self.line_curviness = line_curviness  # (fraction) from user; (see curve_offset)

        self.scale = 1.  # (fraction) Scale the image

        # automatically set some drawing parameters based on the graph data
        self.yseparation = self.max_bundle_size * self.line_width * self.yseparation_frac  # (in points)
        self.xseparation = self.max_bundle_size * self.line_width * self.xseparation_frac  # (in points)
        self.ymargin = self.yseparation  # (in points)
        self.xmargin = self.xseparation  # (in points) small
        self.cluster_width = cluster_width if cluster_width &gt;= 0 else self.auto_cluster_width()  # (in points) from user

        self.curve_offset = self.xseparation * self.line_curviness  # (in points)

        self.font_size = font_size if font_size &gt;= 0 else self.xseparation * 0.6  # (in points) from user

        self.height = 0  # (in points) computed automatically from data
        self.width = 0  # (in points) computed automatically from data

        self.default_line_color = (1., 0., 0., 1.)  # (0, 0.4, 0.8, 1) # r, g, b, a
        self.default_cluster_color = (0., 0., 0., 1.)  # r, g, b, a

    def auto_line_width(self) -&gt; float:
        &#34;&#34;&#34;
        Calculates automatically the largest possible line width.

         The line width is calculated such that the outgoing or incoming connection can only be as big as the cluster.
        Assumes that the connection width is linear.

        :return: The maximum reasonable line width
        &#34;&#34;&#34;
        max_line_width = float(&#39;inf&#39;)
        for cluster in self.clusters:
            line_width_in = line_width_out = float(&#39;inf&#39;)
            if cluster.insize &gt; 0:
                line_width_in = cluster.draw_size / (cluster.insize + self.line_spacing * (len(cluster.incoming) - 1))
            if cluster.outsize &gt; 0:
                line_width_out = cluster.draw_size / (cluster.outsize + self.line_spacing * (len(cluster.outgoing) - 1))
            max_line_width = min(max_line_width, line_width_in, line_width_out)
        return max_line_width

    def auto_cluster_width(self) -&gt; float:
        &#34;&#34;&#34;
        Simple default cluster width

        :return: width that is 5% of the xseparation
        &#34;&#34;&#34;
        return self.xseparation * 0.05

    def build_clusters(self, height_method: str) -&gt; Tuple[List[SizedConnectionCluster], List[List[SizedConnectionCluster]]]:
        &#34;&#34;&#34;
        Create Sugiyamaclusters from the underlying graph

        :param height_method: the string to pass to the cluster for it to determine its vertical size
        :return: List of all clusters, first flattened, second in layers
        :rtype: str
        &#34;&#34;&#34;
        layers = [
            [SizedConnectionCluster(self.g.layers[t][i], height_method)
             for i in range(len(self.g.layers[t]))
             ]
            for t in range(self.g.num_steps)
        ]

        for layer in layers:
            for cluster in layer:
                cluster.build()

        clusters = [x for t in range(self.num_layers) for x in layers[t]]

        return clusters, layers

    ####################################################################################################################
    # -------------------------------------------- Helper Functions -------------------------------------------------- #
    ####################################################################################################################

    def pred(self, c: SizedConnectionCluster) -&gt; Optional[SizedConnectionCluster]:
        &#34;&#34;&#34;
        Returns the predecessor of this cluster (e.g. the cluster with rank-1)
        
        :param c: Cluster to find the predecessor of
        :return: SugiyamaCluster or None if no predecessor exists
        &#34;&#34;&#34;
        if c.rank == 0:
            return None
        return self.ordered[c.tc.layer][c.rank - 1]

    def succ(self, c: SizedConnectionCluster) -&gt; Optional[SizedConnectionCluster]:
        &#34;&#34;&#34;
        Returns the successor of this cluster (e.g. the cluster with rank+1)

        :param c: Cluster to find the successor of
        :return: SugiyamaCluster or None if no successor exists
        &#34;&#34;&#34;
        if c.rank == len(self.layers[c.tc.layer]) - 1:
            return None
        return self.ordered[c.tc.layer][c.rank + 1]

    @staticmethod
    def num_shared_neighbours(u, v):
        return len(set(v.incoming.keys()).intersection(set(u.incoming.keys()))) + len(
            set(v.outgoing.keys()).intersection(set(u.outgoing.keys())))

    ####################################################################################################################
    # --------------------------------------------- Order Functions -------------------------------------------------- #
    ####################################################################################################################

    def reset_order(self) -&gt; None:
        &#34;&#34;&#34;
        Reset the ordering properties of this graph and invalidate successive steps done with previous ordering.

        Clusters are first reset to the position in the original graph and then sorted by supercluster as a base case.
        &#34;&#34;&#34;
        self.ordered = [self.layers[t].copy() for t in range(self.num_layers)]
        for layer in self.ordered:
            for i, cluster in enumerate(layer):
                cluster.rank = i
        self.sort_by_supercluster()
        self.is_ordered = False
        self.is_aligned = False
        self.is_located = False

    def sort_by_supercluster(self) -&gt; None:
        &#34;&#34;&#34;
        Initialize the ranks of clusters to be near other clusters they are connected to

        This works by building superclusters with flood fill. In this case we start new superclusters with the
        highest unplaced cluster, instead of the leftmost one, because this balances much better
        &#34;&#34;&#34;
        pointers = [0] * self.num_layers
        seen = set()
        max_layer_size = max(map(len, self.layers))

        # traverse all clusters top to bottom instead of left to right
        for i in range(max_layer_size):
            for j in range(self.num_layers):
                if i &gt;= len(self.layers[j]) or i &lt; pointers[j]:
                    continue
                cluster = self.ordered[j][i]

                if cluster in seen:
                    continue
                seen.add(cluster)

                # Start new supercluster and fill it with a flood fill
                supercluster = []

                q = deque()
                q.append(cluster)
                while len(q) &gt; 0:
                    current = q.pop()

                    supercluster.append(current)
                    for nb in current.neighbours:
                        if nb not in seen:
                            q.append(nb)
                            seen.add(nb)

                for scluster in supercluster:
                    l = scluster.tc.layer
                    self.swap_clusters(scluster, self.ordered[l][pointers[l]])
                    pointers[l] += 1

    def set_order(self, barycenter_passes: int = 10) -&gt; None:
        &#34;&#34;&#34;
        Order the clusters in self.ordered with the barycenter method

        For each pass of the ordering, the barycenter method is applied once forward and once backward.
        After each pass the ordering is checked whether it changed w.r.t. the previous. All passes are independent
        So we can abort if they are the same.

        :param barycenter_passes: The maximum number of times to repeat the barycenter procedure
        &#34;&#34;&#34;
        # Make copy to compare if ordering has stabilized
        orders_tmp = [order.copy() for order in self.ordered]

        # Keep doing passes until the maximum number has been reached or the order does no longer change
        for i in range(barycenter_passes):
            # print(f&#34;Pass #{i}&#34;)
            self._barycenter()
            # self._barycenter()

            if orders_tmp == self.ordered:
                # print(&#34;Order stabilized&#34;)
                break

            orders_tmp = [order.copy() for order in self.ordered]

        self.is_ordered = True

    @staticmethod
    def _bary_rank_layer(layer: List[SizedConnectionCluster], max_inrank: int, max_outrank: int, alpha: float = 0.5) -&gt; None:
        &#34;&#34;&#34;
        Perform a barycenter sorting on this layer.

        For each cluster the weighted average rank of all incoming and outgoing connections is calculated.
        Then the ordering is decided by a combination of the inrank and outrank, determined by the total size of the
        connections and the alpha factor. If one side has many connections over the other, the side with many
        connections carries more weight. The alpha is the distribution factor, am alpha cose to 1 prioritizes incoming
        connections, an alpha close to 0 prioritizes outgoing. If the alpha is exactly 0 or 1 it is more difficult to
        separate to cluster with the same incoming or outgoing ocnnections.
        If a cluster has no incoming connections it will get the average of the in values of the previous and next
        cluster that do have a valid incoming value. If there is no successive cluster that has a valid value, they are
        given the maximum rank of the previous layer, plus 0.5. Same for the outgoing rank.

        :param layer: the layer to apply the procedure for
        :param max_inrank: The maximum rank in the previous layer
        :param max_outrank:  The maximum rank in the next layer
        :param alpha: Weight factor between 0 and 1 that balances incoming and outgoing
        &#34;&#34;&#34;
        for cluster in layer:
            cluster.update_cluster_ranks()
            # cluster.update_cluster_ranks_median()

        start_inr = 0
        prev_inr = 0.
        start_outr = 0
        prev_outr = 0.
        for i in range(len(layer)):

            if layer[i].inrank &gt;= 0.:
                for j in range(start_inr, i):
                    layer[j].inrank = (prev_inr + layer[i].inrank) / 2.
                start_inr = i + 1
                prev_inr = layer[i].inrank

            if layer[i].outrank &gt;= 0.:
                for j in range(start_outr, i):
                    layer[j].outrank = (prev_outr + layer[i].outrank) / 2.
                start_outr = i + 1
                prev_outr = layer[i].outrank

        for j in range(start_inr, len(layer)):
            layer[j].inrank = max_inrank + 0.5

        for j in range(start_outr, len(layer)):
            layer[j].outrank = max_outrank + 0.5

        total_outsize = sum(map(lambda x: x.outsize, layer))
        total_insize = sum(map(lambda x: x.insize, layer))
        layer.sort(key=lambda c: (c.inrank * total_insize * alpha + c.outrank * total_outsize * (1. - alpha)))

        # layer.sort(key=lambda c: (c.inr * alpha + c.outr * (1.-alpha)))  # simpler
        for i, cluster in enumerate(layer):
            cluster.rank = i

    def _barycenter(self) -&gt; None:
        &#34;&#34;&#34;
        Perform barycenter ordering once forward once backward

        Since each layer ordering depends on the previous layer, in the forward iteration layer 0 remains unchanged
        and in the backwards iteration the last layer is unchanged. So for a full ordering both forwards and backwards
        is needed.
        &#34;&#34;&#34;
        for i in range(self.num_layers):
            layer = self.ordered[i]
            prev_layer_size = (len(self.ordered[i - 1]) - 1) if i &gt; 0 else 0
            next_layer_size = (len(self.ordered[i + 1]) - 1) if i &lt; self.num_layers - 1 else 0

            self._bary_rank_layer(layer, prev_layer_size, next_layer_size, alpha=0.999)

        for i in range(self.num_layers - 2, -1, -1):
            layer = self.ordered[i]
            prev_layer_size = (len(self.ordered[i - 1]) - 1) if i &gt; 0 else 0
            next_layer_size = (len(self.ordered[i + 1]) - 1) if i &lt; self.num_layers - 1 else 0

            self._bary_rank_layer(layer, prev_layer_size, next_layer_size, alpha=0.001)

    def swap_clusters(self, cluster1: SizedConnectionCluster, cluster2: SizedConnectionCluster) -&gt; None:
        &#34;&#34;&#34;
        Swaps the ordered position/rank of two clusters clusters within the same layer

        :param cluster1:
        :param cluster2:
        &#34;&#34;&#34;
        order = self.ordered[cluster1.tc.layer]
        order[cluster1.rank], order[cluster2.rank] = order[cluster2.rank], order[cluster1.rank]
        cluster1.rank, cluster2.rank = cluster2.rank, cluster1.rank

    ####################################################################################################################
    # ---------------------------------------------- Crossing functions ---------------------------------------------- #
    ####################################################################################################################

    # IMPORTANT: These functions do not consider the size of the connection
    # Which is not really a problem, since one crossing with one larger line is not as bad as
    # many crossings with small lines.
    # The main ordering is done with barycenter, these functions can be used for smaller optimizations

    @staticmethod
    def _compare_ranked_lists(upper: List[int], lower: List[int]):
        &#34;&#34;&#34;
        Compare two ordered lists to see how many crossings they have

        Lists are assumed to be sorted low to high and contain ranks. A crossing is when a connection in the
        lower list is above a connection in the higher list.

        :param lower: List of ranks associated with the lower cluster.
        :param upper: List of ranks associated with the higher cluster
        &#34;&#34;&#34;
        j = i = crossings = 0

        while j &lt; len(lower) and i &lt; len(upper):
            if upper[i] &gt; lower[j]:
                j += 1
            elif upper[i] &lt;= lower[j]:
                crossings += j
                i += 1
        crossings += (len(upper) - i) * j

        return crossings

    @classmethod
    def get_num_crossings(cls, cluster1: SizedConnectionCluster, cluster2: SizedConnectionCluster):
        &#34;&#34;&#34;
        Count the number of crossings these 2 cluster have with each other.

        If cluster1 is upper (lower rank) than cluster2, it will return the current number of crossings.
        If cluster2 is upper, it will return the number of crossings as if they were swapped.

        :param cluster1: cluster that is assumed to be the upper cluster
        :param cluster2: cluster that is assumed to be the lower cluster
        &#34;&#34;&#34;
        sins_upper = sorted(map(lambda x: x[0].rank, cluster1.incoming.items()))
        sins_lower = sorted(map(lambda x: x[0].rank, cluster2.incoming.items()))
        souts_upper = sorted(map(lambda x: x[0].rank, cluster1.outgoing.items()))
        souts_lower = sorted(map(lambda x: x[0].rank, cluster2.outgoing.items()))
        return (cls._compare_ranked_lists(sins_upper, sins_lower)
                + cls._compare_ranked_lists(souts_upper, souts_lower))

    def crossing_diff_if_swapped(self, cluster1: SizedConnectionCluster, cluster2: SizedConnectionCluster) -&gt; int:
        &#34;&#34;&#34;
        Determine the relative difference in crossings if we were to swap the rank of these clusters.

        The clusters should be of the same layer.

        :param cluster1: One cluster
        :param cluster2: The other cluster
        :return: The relative difference. Negative indicates a decrease in crossings
        &#34;&#34;&#34;
        if cluster1.rank &gt; cluster2.rank:
            upper, lower = cluster2, cluster1
        else:
            upper, lower = cluster1, cluster2
        return self.get_num_crossings(lower, upper) - self.get_num_crossings(upper, lower)

    ####################################################################################################################
    # ------------------------------------------- Alignment Functions ------------------------------------------------ #
    ####################################################################################################################

    def reset_alignments(self) -&gt; None:
        &#34;&#34;&#34;
        Reset all alignment values and flag all subsequent steps to be out of date.
        &#34;&#34;&#34;
        for cluster in self.clusters:
            cluster.reset_alignment()
        self.is_aligned = False
        self.is_located = False

    def set_alignment(self, direction_flag=FORWARD, max_chain=-1, max_inout_diff=2., stairs_iterations=2) -&gt; None:
        &#34;&#34;&#34;
        Align clusters to be of the same chain to improved readability of the Graph.

        Clusters try to be chained with their median largest incoming connection. A chain is a sequence of clusters
        in successive layers that will all be placed at the same vertical coordinate. If two chains intersect
        at a point, the largest connection is given priority and the other chain is broken. If a cluster cannot
        align with its median largest cluster it will not try for other options.
        After chains are formed, the function will try to reduce staircasing by swapping clusters around.

        :param direction_flag: switch between aligning from left to right (forward) or right to left (backward)
        :param max_chain: Maximum length a chain is allowed, or -1 if a chain can be arbitrarily long
        :param max_inout_diff: Factor to prevent chains from forming when the difference between the largest incoming
        and largest outgoing connection is too big. A factor of two will prevent aligning the cluster if the largest
        outgoing connection is more than twice as large as its largest incoming. This prevents overenthousiastic
        alignments that make little sense. -1 for no limit
        :param stairs_iterations: The amount of iterations for the anti-staircase function.
        &#34;&#34;&#34;
        # Instead of passing on dozens of parameters, this checks if the user has already called the necessary functions
        # if not, it is called with the default parameters
        if not self.is_ordered:
            self.set_order()

        if direction_flag:
            layer_range = range(1, self.num_layers)
        else:
            layer_range = range(self.g.num_steps - 2, -1, -1)

        for layer in layer_range:
            r = -1

            for cluster in self.ordered[layer]:
                if (cluster.insize == 0 or
                        (
                                max_inout_diff &gt;= 0. and cluster.largest_outgoing / cluster.largest_incoming &gt; max_inout_diff)):
                    continue

                # Find cluster in previous layer this one wants to connect to and the weight of the connection
                wanted, connsize = cluster.largest_median_connection(direction=direction_flag)

                if wanted is not None and (max_chain &lt; 0 or wanted.root.chain_length &lt;= max_chain):

                    # Check if this connection contradicts another alignment
                    # priority to the new connection is only given if the weight is higher than all crossings
                    if wanted.rank &lt;= r:
                        if self.has_larger_crossings(wanted, r, connsize):
                            continue
                        self.remove_alignments(wanted, r)

                    wanted.align_with(cluster)
                    r = wanted.rank

        for _ in range(stairs_iterations):
            self.collapse_stairs_iteration()

        self.is_aligned = True

    def has_larger_crossings(self, start_cluster, until_rank, connection_size):
        &#34;&#34;&#34;
        Checks for crossing of at least a certain size until it is found or a certain rank is reached

        :param start_cluster: First cluster to check connections from. Should have a lower rank than until_rank
        :param until_rank: Continue up to and including the cluster of this rank.
        :param connection_size: Threshold for which to check.
        &#34;&#34;&#34;
        cluster = start_cluster
        while cluster is not None and cluster.rank &lt;= until_rank:
            if cluster.align != cluster.root and len(cluster.neighbours[cluster.align]) &gt; connection_size:
                return True
            cluster = self.succ(cluster)
        return False

    def remove_alignments(self, start_cluster: SizedConnectionCluster, until_rank: int):
        &#34;&#34;&#34;
        Removes all alignments of clusters from start_cluster until a certain rank is reached

        :param start_cluster: first cluster to remove alignment from. Should have a lower rank than until_rank
        :param until_rank: continue up to and including the cluster of this rank.
        &#34;&#34;&#34;
        cluster = start_cluster
        while cluster is not None and cluster.rank &lt;= until_rank:
            if cluster.align != cluster.root:  # cluster must not be an endpoint
                cluster.align.reset_alignment()
                cluster.reset_endpoint()
            cluster = self.succ(cluster)

    def adjacent_alignments(self, upper: SizedConnectionCluster, lower: SizedConnectionCluster):
        &#34;&#34;&#34;
        Checks whether two aligments are entirely adjacent or that there exists an alignment in between

        :param upper: cluster in the upper (lower rank) alignment
        :param lower: Cluster in the lower (higher rank) alignment
        :return: True if adjacent, False if there exists an alignment in between
        &#34;&#34;&#34;

        # Set base values
        uroot = upper.root
        lroot = lower.root
        upper = uroot
        lower = lroot

        # Align start layers, at most one while loop will actually run
        while upper.tc.layer &lt; lower.tc.layer:
            upper = upper.align

        while lower.tc.layer &lt; upper.tc.layer:
            lower = lower.align

        # Walk along alignment until either a cluster is found in between or the end of either alignment is reached
        while True:
            if not self.pred(lower) == upper:
                return False
            upper = upper.align
            lower = lower.align
            if upper == uroot or lower == lroot:
                break

        return True

    def crossing_diff_if_swapped_align(self, upper: SizedConnectionCluster, lower: SizedConnectionCluster):
        &#34;&#34;&#34;
        Count the amount of extra crossings this swap would cause. upper and lower should be in adjacent alignments

        Function works by swapping each element and summing the individual differences in crossings

        :param upper: cluster in the upper (lower rank) alignment
        :param lower: Cluster in the lower (higher rank) alignment
        &#34;&#34;&#34;
        uroot = upper.root
        lroot = lower.root
        cluster = lroot
        crossing_diff = 0
        length = 0
        while True:
            predecessor = self.pred(cluster)
            if predecessor is not None and predecessor.root == uroot:
                crossing_diff += self.crossing_diff_if_swapped(cluster, predecessor)
                length += 1
            cluster = cluster.align
            if cluster == lroot:
                break
        return crossing_diff - 2 * (length - 1)

    def swap_align(self, upper: SizedConnectionCluster, lower: SizedConnectionCluster):
        &#34;&#34;&#34;
        Count the amount of extra crossings this swap would cause. upper and lower should be in adjacent alignments

        Function works by swapping each element and summing the individual differences in crossings

        :param upper: cluster in the upper (lower rank) alignment
        :param lower: Cluster in the lower (higher rank) alignment
        &#34;&#34;&#34;
        uroot = upper.root
        lroot = lower.root
        cluster = lroot
        while True:
            predecessor = self.pred(cluster)
            if predecessor is not None and predecessor.root == uroot:
                self.swap_clusters(cluster, predecessor)

            cluster = cluster.align
            if cluster == lroot:
                break

    def collapse_stairs_iteration(self, minimum_want=3, allowed_extra_crossings=0):
        &#34;&#34;&#34;
        Mitigates the staircase effect on connected parts of the graph

        The goal is to move shorter chains closer to their desired position. Shorter chains have a better chance to
        fit tightly as opposed to longer chains.
        For every two adjacent alignments, it is always that either root is a predecessor or successor to a cluster
        in the other alignment. As such we only need to check the roots, but we have to check both the direction this
        alignment wants to go and the direction the predecessor alignment and successor alignment of the root want to go
        We first establish the desired direction of each alignment in its root. Then for each root we check 4 cases:
        case 1: this alignment wants to go up
        case 2: this alignment wants to go down
        case 3: the successor wants to go up
        case 4: the predecessor wants to go down
        These cases are mutually exclusive, even though case 1 and 4 cause the same swap, as do 2 and 3.
        Preference is given to case 1 and 2. It is a possibility that both case 3 and 4 are valid, but after execution
        of either case, the other will be obstructed, because the predecessor and successor change. Cases are looped
        until a stop condition is reached. In short for a swap to occur the following things must hold:
        a. in case 1 and 2, this chain must be shorter than the predecessor/successor. For case 3 and 4 this is inverted
        b. the shorter chain must move in its desired direction, updated after every step.
            A direction value between 2 and -2 (inclusive) is optimal and is treated as no desired direction.
        c. the alignments must be fully adjacent (ask me if this requirement is unclear)
        d. the swap may not increase the amount of crossings in the graph more than a certain amount (default: 0)
        &#34;&#34;&#34;
        for cluster in self.clusters:
            if cluster.root != cluster:
                continue
            cluster.update_wanted_direction()

        for cluster in self.clusters:
            if cluster.root != cluster:
                continue

            successor = self.succ(cluster)
            predecessor = self.pred(cluster)

            # Case 1
            while (cluster.wanted_direction &lt;= -minimum_want
                   and predecessor is not None and predecessor.root.chain_length &gt; cluster.chain_length
                   and self.adjacent_alignments(predecessor, cluster)
                   and self.crossing_diff_if_swapped_align(predecessor, cluster) &lt;= allowed_extra_crossings):
                self.swap_align(predecessor, cluster)
                predecessor.root.update_wanted_direction()
                cluster.update_wanted_direction()
                predecessor = self.pred(cluster)

            # Case 2
            while (cluster.wanted_direction &gt;= minimum_want
                   and successor is not None and successor.root.chain_length &gt; cluster.chain_length
                   and self.adjacent_alignments(cluster, successor)
                   and self.crossing_diff_if_swapped_align(cluster, successor) &lt;= allowed_extra_crossings):
                self.swap_align(cluster, successor)
                successor.root.update_wanted_direction()
                cluster.update_wanted_direction()
                successor = self.succ(cluster)

            # Case 3
            while (successor is not None and successor.root.chain_length &lt;= cluster.chain_length
                   and successor.root.wanted_direction &lt; -minimum_want
                   and self.adjacent_alignments(cluster, successor)
                   and self.crossing_diff_if_swapped_align(cluster, successor) &lt;= allowed_extra_crossings):
                self.swap_align(cluster, successor)
                successor.root.update_wanted_direction()
                cluster.update_wanted_direction()
                successor = self.succ(cluster)

            # Case 4
            while (predecessor is not None and predecessor.root.chain_length &lt; cluster.chain_length
                   and predecessor.root.wanted_direction &gt;= minimum_want
                   and self.adjacent_alignments(predecessor, cluster)
                   and self.crossing_diff_if_swapped_align(predecessor, cluster) &lt;= allowed_extra_crossings):
                self.swap_align(predecessor, cluster)
                predecessor.root.update_wanted_direction()
                cluster.update_wanted_direction()
                predecessor = self.pred(cluster)

    ####################################################################################################################
    # ------------------------------------------- Location Functions ------------------------------------------------- #
    ####################################################################################################################

    def set_locations(self, averaging_iterations=5) -&gt; None:
        &#34;&#34;&#34;
        Place the chains that have been identified and ordered.

        Chains are placed as compactly and high as possible initially. This can introduce unneccessary distances,
        so this value is treated as an upper bound. After the bounds have been established, chains will try to move as
        close to the average position of its connections outside itself below that bound, without moving past the
        chain below.

        :param averaging_iterations: The amount of times the averaging should be performed, as each iteration changes
        how low a cluster w.r.t. the position change of its successor.
        &#34;&#34;&#34;
        # Instead of passing on dozens of parameters, this checks if the user has already called the necessary functions
        # if not, it is called with the default parameters
        if not self.is_aligned:
            self.set_alignment()

        self.set_x_positions()

        for cluster in self.clusters:
            if cluster.root == cluster:
                self.place_block(cluster)

        self.set_y_positions()

        for _ in range(averaging_iterations):
            for cluster in self.clusters:
                cluster._y = -1.

            for cluster in self.clusters:
                if cluster.root == cluster:
                    self.avg_block(cluster)

            self.set_y_positions()

        self.check_locations()
        self.is_located = True

    def check_locations(self, excepting=True):
        &#34;&#34;&#34;
        Check whether the determined locations are consistent with the determined ordering

        :param excepting: Whether to raise an exception if the locations are inconsistent
        :return:
        &#34;&#34;&#34;
        for order in self.ordered:
            prev = -1
            for cluster in order:
                if cluster.y &lt;= prev:
                    if excepting:
                        raise UnorderedException(
                            f&#34;Locations are not in order of ranks: {cluster} is higher than {self.pred(cluster)}&#34;)
                    else:
                        print(f&#34;{cluster} is higher than {self.pred(cluster)}&#34;)
                prev = cluster.y

    def center_distance(self, u: SizedConnectionCluster, v: SizedConnectionCluster, non_connectedness_factor=1.):
        &#34;&#34;&#34;
        Calculate the distance between the centers of two cluster if they were to be adjacent

        :param u: Cluster
        :param v: Cluster
        :param non_connectedness_factor: Factor by which to increase the distance if the clusters do not share neighbors
        &#34;&#34;&#34;
        if non_connectedness_factor != 1. and self.num_shared_neighbours(u, v) == 0:
            return self.yseparation * non_connectedness_factor + (u.draw_size + v.draw_size) / 2.
        return self.yseparation + (u.draw_size + v.draw_size) / 2.

    def place_block(self, root):
        &#34;&#34;&#34;
        Place an aligned section by placing all blocks above it and then fitting it as high as possible

        :param root: Root of the alignment to place
        &#34;&#34;&#34;

        # If block was already placed, skip
        if root._y &lt; 0.:
            root._y = 0.
            cluster = root

            while True:
                if cluster.rank &gt; 0:
                    predecessor = self.pred(cluster)
                    self.place_block(predecessor.root)

                    root._y = max(root._y, predecessor.root._y + self.center_distance(predecessor, cluster))

                cluster = cluster.align
                if cluster == root:
                    break

    def avg_block(self, root):
        &#34;&#34;&#34;
        Place an aligned section by taking the average position

        place_block() puts all sections as high as they will go from top to bottom. This creates an upper bound on the
        alignment. Now from bottom to top we take the position this alignment would be placed based on average,
        bounded by the upper bound already calculated and the lower bound by the average of the block below.
        &#34;&#34;&#34;
        if root._y &lt; 0.:
            root._y = 0.
            cluster = root
            upper_bound = root.y
            lower_bound = float(&#39;inf&#39;)
            total = 0.
            ctr = 0

            while True:
                successor = self.succ(cluster)
                if successor is not None:
                    self.avg_block(successor.root)

                    lower_bound = min(lower_bound, successor.root._y - self.center_distance(cluster, successor))

                for k, value in cluster.outgoing.items():
                    if k == cluster.align:
                        continue
                    ctr += len(value)
                    total += k.y * len(value)

                for k, value in cluster.align.incoming.items():
                    if k == cluster:
                        continue
                    ctr += len(value)
                    total += k.y * len(value)

                cluster = cluster.align
                if cluster == root:
                    break
            if ctr == 0:
                root._y = upper_bound
            else:
                root._y = max(upper_bound, min(lower_bound, total / ctr))

    def set_x_positions(self):
        &#34;&#34;&#34;
        Update all x positions of all the clusters, as determined by their layer
        &#34;&#34;&#34;
        for cluster in self.clusters:
            cluster.x = self.xmargin + self.xseparation * cluster.tc.layer
        self.width = 2 * self.xmargin + self.xseparation * self.num_layers

    def set_y_positions(self) -&gt; None:
        &#34;&#34;&#34;
        Update all y positions of all the clusters, as determined by the algorithm. Also trim possible top margin.
        &#34;&#34;&#34;
        min_y = min(map(lambda x: x.root._y - x.draw_size / 2., self.clusters))
        for cluster in self.clusters:
            cluster.y = cluster.root._y + self.ymargin - min_y

        self.height = max(map(lambda x: x.root.y + x.draw_size / 2., self.clusters)) + 2*self.ymargin

    ####################################################################################################################
    # ------------------------------------------ Statistics Functions ------------------------------------------------ #
    ####################################################################################################################

    def streak_below(self, data: List[Number], num: Number) -&gt; int:
        &#34;&#34;&#34;
        Returns the longest streak that the data points are below some threshold.

        :param data: Data to analyse
        :param num: Threshold value
        :return: Largest count of consecutive points below the threshold
        &#34;&#34;&#34;
        longest = 0
        current = 0
        for d in data:
            if d &lt; num:
                current += 1
                if current &gt; longest:
                    longest = current
            else:
                current = 0
        return longest

    def streak_no_cross(self, data: List[Number], num: Number) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;
        Returns the longest streak of the datapoints not crossing the threshold in either direction and the total
        number of times the datapoints cross the threshold.

        :param data: Data to analyse
        :param num: Threshold value
        :return: Tuple of the longest streak and total amount of crossings
        &#34;&#34;&#34;
        longest = 1
        current = 1
        crossings = 0
        for i in range(len(data) - 1):
            if (data[i] &lt; num) == (data[i + 1] &lt; num):
                current += 1
                if current &gt; longest:
                    longest = current
            else:
                current = 1
                crossings += 1
        return longest, crossings

    ####################################################################################################################
    # ------------------------------------------- Drawing Functions -------------------------------------------------- #
    ####################################################################################################################

    def calculate_line_origins(self, source_cluster):
        &#34;&#34;&#34;
        Calculate the absolute origins for each line incident to this cluster

        This is calculated by sorting the other endpoints and &#34;empirically&#34; set them
        one after the other around the center.
        &#34;&#34;&#34;
        incomings = list(source_cluster.incoming.items())
        incomings.sort(key=lambda x: x[0].rank)
        outgoings = list(source_cluster.outgoing.items())
        outgoings.sort(key=lambda x: x[0].rank)

        # The key is a pair of (source, target)
        # The value is the y coordinate of where the endpoint in source should originate.
        pairs = {}

        # Space to leave between each line
        line_separation = self.line_width * self.line_spacing

        # We calculate around the center of the cluster, so this is the offset to start at
        half_in_width = (source_cluster.insize * self.line_width + line_separation * (len(incomings) - 1)) / 2.

        # source_cluster.y refers to the center of the cluster, so subtract half the width such that the center align
        cumulative = source_cluster.y - half_in_width
        for (target_cluster, members) in incomings:
            thickness = len(members) * self.line_width
            pairs[(source_cluster, target_cluster)] = cumulative + thickness / 2.
            cumulative += thickness + line_separation

        # We calculate around the center of the cluster, so this is the offset to start at
        half_out_width = (source_cluster.outsize * self.line_width + line_separation * (len(outgoings) - 1)) / 2.

        # source_cluster.y refers to the center of the cluster, so subtract half the width such that the center align
        cumulative = source_cluster.y - half_out_width
        for (target_cluster, members) in outgoings:
            thickness = len(members) * self.line_width
            pairs[(source_cluster, target_cluster)] = cumulative + thickness / 2.
            cumulative += thickness + line_separation

        return pairs

    def draw_line(self, source: SizedConnectionCluster, target: SizedConnectionCluster,
                  line_coordinates: dict, colormap: dict,
                  context: cairo.Context,
                  show_annotations=False):
        &#34;&#34;&#34;
        Draws the connection between source and target with label colors

        The line is divided in sections according to the labels of the nodes in this connection.
        For each unique label a line is drawn in the associated color with exact offset as to seem one single cohesive

        :param source: One endpoint of the line
        :param target: The other endpoint of the line
        :param line_coordinates: Dictionary with absolute coordinates of the endpoints
        :param colormap: Dictionary with label names and associated colors
        :param context: cairo context to draw this line on
        :param show_annotations: provides annotations when a line changes size significantly
        &#34;&#34;&#34;
        members = source.neighbours[target]
        num_members = len(members)
        thickness = num_members * self.line_width
        half_thickness = len(members) * self.line_width / 2.

        labels = Counter(map(lambda x: x.meta_string, members))
        labels = [(colormap.get(lbl, self.default_line_color), cnt / num_members) for (lbl, cnt) in
                  sorted(list(labels.items()))]

        y_source = line_coordinates[(source, target)]
        y_target = line_coordinates[(target, source)]
        context.save()
        context.rectangle(source.x, 0, target.x, self.height)
        context.clip()

        if len(labels) == 1:
            (r, g, b, a) = labels[0][0]
            context.set_source_rgba(r, g, b, a)
            context.set_line_width(thickness)
            context.move_to(source.x, y_source)
            context.curve_to(source.x + self.curve_offset, y_source,
                             target.x - self.curve_offset, y_target,
                             target.x, y_target)

            context.stroke()

        else:
            coloured_bezier(context,
                            (source.x, y_source),
                            (source.x + self.curve_offset, y_source),
                            (target.x - self.curve_offset, y_target),
                            (target.x, y_target),
                            labels,
                            thickness,
                            detail=min(100, max(4, int(abs(y_target - y_source) * self.line_width))))

        if show_annotations:
            # draw some annotatations of the bundle size
            context.set_source_rgb(0, 0, 0)
            context.select_font_face(&#34;Helvetica&#34;, cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_NORMAL)
            context.set_font_size(min(self.line_width * len(members), self.xseparation * 0.7))  # in user space units

            if len(members) &gt;= 1.5 * max(map(len, source.incoming.values()), default=0.):
                to_print = str(len(members))
                _, _, width, height, _, _ = context.text_extents(to_print)
                context.move_to(source.x + self.xseparation / 2 - width / 2,
                                (y_source + y_target) / 2 + height / 2)
                context.show_text(to_print)
                context.stroke()
        context.restore()

    def fade_cluster(self, context: cairo.Context, cluster: SizedConnectionCluster, colormap: Dict, direction):
        &#34;&#34;&#34;
        Draw a fading line into or from a certain cluster.

        :param context: cairo Context to draw on
        :param cluster: Cluster to use as source
        :param colormap: map of coloring for the names of the nodes in the cluster
        :param direction: True for a fade in, False for a fade out
        &#34;&#34;&#34;
        colors = [(colormap.get(lbl, self.default_line_color), cnt / len(cluster)) for (lbl, cnt) in
                  sorted(list(Counter(map(lambda x: x.meta_string, cluster.members)).items()))]
        if direction:
            coloured_bezier(context,
                            (cluster.x - self.xseparation / 3., cluster.y),
                            (cluster.x, cluster.y),
                            (cluster.x, cluster.y),
                            (cluster.x, cluster.y),
                            colors=colors, width=self.line_width * len(cluster), detail=4, fade=&#39;in&#39;)
        else:
            coloured_bezier(context,
                            (cluster.x, cluster.y),
                            (cluster.x, cluster.y),
                            (cluster.x, cluster.y),
                            (cluster.x + self.xseparation / 3., cluster.y),
                            colors=colors, width=self.line_width * len(cluster), detail=4, fade=&#39;out&#39;)

    def draw_timestamps(self, context: cairo.Context, timestamp_translator) -&gt; None:
        &#34;&#34;&#34;
        Separate surface that the timestamps are drawn onto.

        :param timestamp_translator: Object that converts a layer number to a layer identifier
        :return: Surface with drawn timestamps in the same offsets as the layers.
        &#34;&#34;&#34;

        context.set_source_rgb(0, 0, 0)
        context.select_font_face(&#34;Helvetica&#34;, cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_NORMAL)
        context.set_font_size(self.font_size)  # in user space units # self.xseparation * 0.6

        for t in range(self.num_layers):
            context.move_to(self.xmargin + t * self.xseparation, 0)
            context.line_to(self.xmargin + t * self.xseparation, self.xseparation * 0.2)

            to_print = str(t)
            if timestamp_translator:
                to_print = timestamp_translator[t]

            _, _, width, height, _, _ = context.text_extents(to_print)

            context.move_to(self.xmargin + t * self.xseparation + height / 2,
                            width + self.xseparation * 0.3)

            context.save()
            context.rotate(math.radians(270))  # angle in rad
            context.show_text(to_print)
            context.restore()

        context.stroke()

    def draw_connections(self, context: cairo.Context, colormap: dict, show_annotations: bool, fading: bool) -&gt; None:
        &#34;&#34;&#34;
        Returns a cairo surface with just the connections drawn onto them.

        :param colormap: dictionary that converts a node name to a color value
        :param show_annotations: Flag to show additional information per connection
        :param fading: Flag to also draw the fade in and out connections per cluster
        :return: cairo surface with connections
        &#34;&#34;&#34;

        line_coordinates = dict()  # k: (source, target), v: y-coordinate of endpoint in source.

        for cluster in self.clusters:
            line_coordinates.update(self.calculate_line_origins(cluster))

        if fading:
            for cluster in self.clusters:
                if cluster.insize == 0:
                    self.fade_cluster(context, cluster, colormap, direction=INCOMING)
                if cluster.outsize == 0:
                    self.fade_cluster(context, cluster, colormap, direction=OUTGOING)

        already_drawn = set()

        for (source, target) in line_coordinates.keys():
            if (target, source) in already_drawn:
                continue

            self.draw_line(source, target, line_coordinates, colormap, context, show_annotations=show_annotations)
            # self.draw_line_monochrome(source, target, line_coordinates, context)

            already_drawn.add((source, target))
            already_drawn.add((target, source))

    def draw_clusters(self, context: cairo.Context) -&gt; None:
        &#34;&#34;&#34;
        Returns a surface with all cluster drawn on them to be overlaid on the connection surface
        :return:
        &#34;&#34;&#34;
        (r, g, b, a) = self.default_cluster_color

        context.set_line_width(self.cluster_width)
        context.set_source_rgba(r, g, b, a)

        for cluster in self.clusters:
            cx, cy = cluster.pos()
            context.move_to(cx, cy - cluster.draw_size / 2.)
            context.line_to(cx, cy + cluster.draw_size / 2.)
            context.stroke()

    def draw_debug(self, context: cairo.Context, debug_info: Set[str]) -&gt; None:
        &#34;&#34;&#34;
        Surface that shows invasive debug information per connection or cluster.

        Accepts:
        &#39;swap_above&#39;: the relative difference in crossings if a cluster was to be swapped with the cluster above it
        &#39;ranks&#39;: Show the in and out rank information as calculated by the barycenter procedure.
        &#39;id&#39;: Show the layer and id of a cluster.

        :param debug_info: List of debug items to show.
        :return: cairo Surface with debug information
        &#34;&#34;&#34;
        context.set_source_rgb(0.2, 0.2, 0.2)
        context.select_font_face(&#34;Helvetica&#34;, cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_NORMAL)
        context.set_font_size(self.font_size * 0.2)

        for cluster in self.clusters:
            cx, cy = cluster.pos()
            if cluster.root == cluster:
                if &#34;swap_above&#34; in debug_info:
                    context.move_to(cx + self.xseparation * 0.1, cy)
                    context.show_text(
                        f&#34;{self.crossing_diff_if_swapped_align(self.pred(cluster), cluster) if self.pred(cluster) is not None else 0:.2f}&#34;)

            if &#34;ranks&#34; in debug_info:
                context.move_to(cx + self.xseparation * 0.1, cy)
                context.show_text(f&#34;{cluster.outrank:.2f}&#34;)
                context.move_to(cx - self.xseparation * 0.3, cy)
                context.show_text(f&#34;{cluster.inrank:.2f}&#34;)

            if &#34;id&#34; in debug_info:
                context.move_to(cx + self.xseparation * 0.1, cy)
                context.show_text(f&#34;{cluster.tc.id}&#34;)
                context.move_to(cx - self.xseparation * 0.3, cy)
                context.show_text(f&#34;{cluster.tc.layer}&#34;)

    def draw_stats(self, context: cairo.Context, data: Collection[str], maxheight: int = 200) -&gt; None:
        &#34;&#34;&#34;
        Returns a recording surface to be played back with statistics about the graph.

        Currently accepted statistic strings are &#34;in_out_difference&#34;, &#34;layer_num_clusters&#34;, &#34;layer_num_members&#34;,
        &#34;homogeneity&#34;, &#34;homogeneity_diff&#34;. See for explanations the respective functions in TimeGraph.
        Per statistic the height of the drawing is one third of the graph height or maxheight, whichever is lower.

        :param maxheight: Maximum height in points of per statistic
        :param data: Iterable of strings of the statistics to show (in order)
        :return: cairo recording of statistics
        &#34;&#34;&#34;
        h = min(self.height / 3, maxheight)

        marg = 0.1  # Margin around the drawing and in between different stats, in percent of h.

        for i, name in enumerate(data):

            if name == &#34;in_out_difference&#34;:
                d = self.g.layer_in_out_diff()
            elif name == &#34;layer_num_clusters&#34;:
                d = self.g.layer_num_clusters()
            elif name == &#34;layer_num_members&#34;:
                d = self.g.layer_num_members()
            elif name == &#34;homogeneity&#34;:
                d = self.g.relative_continuity()
            elif name == &#34;homogeneity_diff&#34;:
                d = self.g.relative_continuity_diff()
            else:
                print(f&#34;Name {name} not found!&#34;)
                continue

            maxval = max(d)
            scale = (h * (1. - 2 * marg)) / maxval  # Scale of the graph.

            context.set_line_width(h/100)

            # Draw base axes
            context.set_source_rgba(0, 0, 0, 1)
            context.move_to(self.xmargin * 0.95, (i + marg) * h)
            context.line_to(self.xmargin * 0.9, (i + marg) * h)
            context.line_to(self.xmargin * 0.9, (i + 1. - marg) * h)
            context.line_to(self.width - self.xmargin, (i + 1. - marg) * h)
            context.stroke()

            # Show top value (bottom is always 0)
            text_to_show = f&#34;{maxval:.2f}&#34;
            context.select_font_face(&#34;Helvetica&#34;, cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_NORMAL)
            context.set_font_size(min(self.font_size * 0.4, h / 10))
            _, _, tw, th, _, _ = context.text_extents(text_to_show)
            context.move_to(self.xmargin * 0.85 - tw, (i + marg) * h + th)
            context.show_text(text_to_show)

            # Draw line of average
            avg = sum(d) / len(d)
            context.set_source_rgba(0, 1, 0, 1)
            context.move_to(self.xmargin, (i + marg) * h + (maxval - avg) * scale)
            context.line_to(self.width - self.xmargin, (i + marg) * h + (maxval - avg) * scale)
            context.stroke()

            # Draw data
            context.set_source_rgba(0, 0, 1, 1)
            context.move_to(self.xmargin, (i + marg) * h + (maxval - d[0]) * scale)
            for j in range(1, len(d)):
                context.line_to(self.xmargin + j * self.xseparation, (i + marg) * h + (maxval - d[j]) * scale)

            context.stroke()

            # Show additional information in text
            streak, crossings = self.streak_no_cross(d, avg)
            text_to_show = f&#34;{name}: avg ({avg:.3f}), streak ({streak}), crossings ({crossings}), cross_percent ({(crossings / len(d)):2f})&#34;

            context.set_font_size(min(self.font_size * 0.5, h / 8))
            _, _, tw, th, _, _ = context.text_extents(text_to_show)
            context.move_to(0.3 * self.xseparation + self.xmargin, (i + marg) * h + th)
            context.show_text(text_to_show)

    def get_timestamp_height(self, timestamp_translator):
        tmpsurf = cairo.RecordingSurface(cairo.CONTENT_COLOR_ALPHA, None)
        context = cairo.Context(tmpsurf)
        context.select_font_face(&#34;Helvetica&#34;, cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_NORMAL)
        context.set_font_size(self.font_size)

        h = max([context.text_extents(timestamp_translator.get(t, str(t)))[2] for t in range(self.num_layers)]) + 0.3*self.xseparation
        tmpsurf.finish()
        return h

    def get_stat_height(self, stat_info, maxheight):
        return min(self.height / 3, maxheight) * len(stat_info)

    def draw_graph(self, filename: str = &#34;output/example.svg&#34;,
                   colormap=None,
                   show_timestamps=True, timestamp_translator=None,
                   show_annotations=False, debug_info=None, stats_info=None,
                   fading=False, scale=1.):

        if colormap is None:
            colormap = dict()

        if timestamp_translator is None:
            timestamp_translator = dict()

        # Instead of passing on dozens of parameters, this checks if the user has already called the necessary functions
        # if not, it is called with the default parameters
        if not self.is_located:
            self.set_locations()

        canvaswidth = self.width
        canvasheight = self.height
        if show_timestamps:
            timeheight = self.get_timestamp_height(timestamp_translator) + self.ymargin
            canvasheight += timeheight

        if stats_info is not None:
            canvasheight += self.get_stat_height(stats_info, 200) + self.ymargin

        surface = cairo.SVGSurface(filename, canvaswidth * scale, canvasheight * scale)
        context = cairo.Context(surface)
        context.scale(scale, scale)

        self.draw_connections(context, colormap, show_annotations, fading)
        self.draw_clusters(context)
        if debug_info is not None:
            self.draw_debug(context, debug_info)
        context.translate(0, self.height)
        # offset = self.height + 2*self.ymargin
        if show_timestamps:
            self.draw_timestamps(context, timestamp_translator)
            context.translate(0, timeheight)
        if stats_info is not None:
            self.draw_stats(context, stats_info)

        surface.flush()
        surface.finish()</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="tgv.layout.SizedConnectionLayout.get_num_crossings"><code class="name flex">
<span>def <span class="ident">get_num_crossings</span></span>(<span>cluster1:<a title="tgv.layout.SizedConnectionCluster" href="#tgv.layout.SizedConnectionCluster">SizedConnectionCluster</a>, cluster2:<a title="tgv.layout.SizedConnectionCluster" href="#tgv.layout.SizedConnectionCluster">SizedConnectionCluster</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Count the number of crossings these 2 cluster have with each other.</p>
<p>If cluster1 is upper (lower rank) than cluster2, it will return the current number of crossings.
If cluster2 is upper, it will return the number of crossings as if they were swapped.</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>cluster1</code></strong></dt>
<dd><p>cluster that is assumed to be the upper cluster</p></dd>
<dt><strong><code>cluster2</code></strong></dt>
<dd><p>cluster that is assumed to be the lower cluster</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_num_crossings(cls, cluster1: SizedConnectionCluster, cluster2: SizedConnectionCluster):
    &#34;&#34;&#34;
    Count the number of crossings these 2 cluster have with each other.

    If cluster1 is upper (lower rank) than cluster2, it will return the current number of crossings.
    If cluster2 is upper, it will return the number of crossings as if they were swapped.

    :param cluster1: cluster that is assumed to be the upper cluster
    :param cluster2: cluster that is assumed to be the lower cluster
    &#34;&#34;&#34;
    sins_upper = sorted(map(lambda x: x[0].rank, cluster1.incoming.items()))
    sins_lower = sorted(map(lambda x: x[0].rank, cluster2.incoming.items()))
    souts_upper = sorted(map(lambda x: x[0].rank, cluster1.outgoing.items()))
    souts_lower = sorted(map(lambda x: x[0].rank, cluster2.outgoing.items()))
    return (cls._compare_ranked_lists(sins_upper, sins_lower)
            + cls._compare_ranked_lists(souts_upper, souts_lower))</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.num_shared_neighbours"><code class="name flex">
<span>def <span class="ident">num_shared_neighbours</span></span>(<span>u, v)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def num_shared_neighbours(u, v):
    return len(set(v.incoming.keys()).intersection(set(u.incoming.keys()))) + len(
        set(v.outgoing.keys()).intersection(set(u.outgoing.keys())))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tgv.layout.SizedConnectionLayout.adjacent_alignments"><code class="name flex">
<span>def <span class="ident">adjacent_alignments</span></span>(<span>self, upper:<a title="tgv.layout.SizedConnectionCluster" href="#tgv.layout.SizedConnectionCluster">SizedConnectionCluster</a>, lower:<a title="tgv.layout.SizedConnectionCluster" href="#tgv.layout.SizedConnectionCluster">SizedConnectionCluster</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether two aligments are entirely adjacent or that there exists an alignment in between</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>upper</code></strong></dt>
<dd><p>cluster in the upper (lower rank) alignment</p></dd>
<dt><strong><code>lower</code></strong></dt>
<dd><p>Cluster in the lower (higher rank) alignment</p></dd>
</dl>
<h2 id="returns">Returns:</h2>
<dl>
<dd><p>True if adjacent, False if there exists an alignment in between</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjacent_alignments(self, upper: SizedConnectionCluster, lower: SizedConnectionCluster):
    &#34;&#34;&#34;
    Checks whether two aligments are entirely adjacent or that there exists an alignment in between

    :param upper: cluster in the upper (lower rank) alignment
    :param lower: Cluster in the lower (higher rank) alignment
    :return: True if adjacent, False if there exists an alignment in between
    &#34;&#34;&#34;

    # Set base values
    uroot = upper.root
    lroot = lower.root
    upper = uroot
    lower = lroot

    # Align start layers, at most one while loop will actually run
    while upper.tc.layer &lt; lower.tc.layer:
        upper = upper.align

    while lower.tc.layer &lt; upper.tc.layer:
        lower = lower.align

    # Walk along alignment until either a cluster is found in between or the end of either alignment is reached
    while True:
        if not self.pred(lower) == upper:
            return False
        upper = upper.align
        lower = lower.align
        if upper == uroot or lower == lroot:
            break

    return True</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.auto_cluster_width"><code class="name flex">
<span>def <span class="ident">auto_cluster_width</span></span>(<span>self) >float</span>
</code></dt>
<dd>
<div class="desc"><p>Simple default cluster width</p>
<h2 id="returns">Returns:</h2>
<dl>
<dd><p>width that is 5% of the xseparation</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def auto_cluster_width(self) -&gt; float:
    &#34;&#34;&#34;
    Simple default cluster width

    :return: width that is 5% of the xseparation
    &#34;&#34;&#34;
    return self.xseparation * 0.05</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.auto_line_width"><code class="name flex">
<span>def <span class="ident">auto_line_width</span></span>(<span>self) >float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates automatically the largest possible line width.</p>
<blockquote>
<p>The line width is calculated such that the outgoing or incoming connection can only be as big as the cluster.</p>
</blockquote>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<span class="docutils literal">&lt;string&gt;</span>, line 4)</p>
<p>Block quote ends without a blank line; unexpected unindent.</p>
</div>
<p>Assumes that the connection width is linear.</p>
<h2 id="returns">Returns:</h2>
<dl>
<dd><p>The maximum reasonable line width</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def auto_line_width(self) -&gt; float:
    &#34;&#34;&#34;
    Calculates automatically the largest possible line width.

     The line width is calculated such that the outgoing or incoming connection can only be as big as the cluster.
    Assumes that the connection width is linear.

    :return: The maximum reasonable line width
    &#34;&#34;&#34;
    max_line_width = float(&#39;inf&#39;)
    for cluster in self.clusters:
        line_width_in = line_width_out = float(&#39;inf&#39;)
        if cluster.insize &gt; 0:
            line_width_in = cluster.draw_size / (cluster.insize + self.line_spacing * (len(cluster.incoming) - 1))
        if cluster.outsize &gt; 0:
            line_width_out = cluster.draw_size / (cluster.outsize + self.line_spacing * (len(cluster.outgoing) - 1))
        max_line_width = min(max_line_width, line_width_in, line_width_out)
    return max_line_width</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.avg_block"><code class="name flex">
<span>def <span class="ident">avg_block</span></span>(<span>self, root)</span>
</code></dt>
<dd>
<div class="desc"><p>Place an aligned section by taking the average position</p>
<p>place_block() puts all sections as high as they will go from top to bottom. This creates an upper bound on the
alignment. Now from bottom to top we take the position this alignment would be placed based on average,
bounded by the upper bound already calculated and the lower bound by the average of the block below.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def avg_block(self, root):
    &#34;&#34;&#34;
    Place an aligned section by taking the average position

    place_block() puts all sections as high as they will go from top to bottom. This creates an upper bound on the
    alignment. Now from bottom to top we take the position this alignment would be placed based on average,
    bounded by the upper bound already calculated and the lower bound by the average of the block below.
    &#34;&#34;&#34;
    if root._y &lt; 0.:
        root._y = 0.
        cluster = root
        upper_bound = root.y
        lower_bound = float(&#39;inf&#39;)
        total = 0.
        ctr = 0

        while True:
            successor = self.succ(cluster)
            if successor is not None:
                self.avg_block(successor.root)

                lower_bound = min(lower_bound, successor.root._y - self.center_distance(cluster, successor))

            for k, value in cluster.outgoing.items():
                if k == cluster.align:
                    continue
                ctr += len(value)
                total += k.y * len(value)

            for k, value in cluster.align.incoming.items():
                if k == cluster:
                    continue
                ctr += len(value)
                total += k.y * len(value)

            cluster = cluster.align
            if cluster == root:
                break
        if ctr == 0:
            root._y = upper_bound
        else:
            root._y = max(upper_bound, min(lower_bound, total / ctr))</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.build_clusters"><code class="name flex">
<span>def <span class="ident">build_clusters</span></span>(<span>self, height_method:str) >Tuple[List[<a title="tgv.layout.SizedConnectionCluster" href="#tgv.layout.SizedConnectionCluster">SizedConnectionCluster</a>],List[List[<a title="tgv.layout.SizedConnectionCluster" href="#tgv.layout.SizedConnectionCluster">SizedConnectionCluster</a>]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Create Sugiyamaclusters from the underlying graph</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>height_method</code></strong></dt>
<dd><p>the string to pass to the cluster for it to determine its vertical size</p></dd>
</dl>
<h2 id="returns">Returns:</h2>
<dl>
<dt><code>str</code></dt>
<dd><p>List of all clusters, first flattened, second in layers</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_clusters(self, height_method: str) -&gt; Tuple[List[SizedConnectionCluster], List[List[SizedConnectionCluster]]]:
    &#34;&#34;&#34;
    Create Sugiyamaclusters from the underlying graph

    :param height_method: the string to pass to the cluster for it to determine its vertical size
    :return: List of all clusters, first flattened, second in layers
    :rtype: str
    &#34;&#34;&#34;
    layers = [
        [SizedConnectionCluster(self.g.layers[t][i], height_method)
         for i in range(len(self.g.layers[t]))
         ]
        for t in range(self.g.num_steps)
    ]

    for layer in layers:
        for cluster in layer:
            cluster.build()

    clusters = [x for t in range(self.num_layers) for x in layers[t]]

    return clusters, layers</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.calculate_line_origins"><code class="name flex">
<span>def <span class="ident">calculate_line_origins</span></span>(<span>self, source_cluster)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the absolute origins for each line incident to this cluster</p>
<p>This is calculated by sorting the other endpoints and "empirically" set them
one after the other around the center.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_line_origins(self, source_cluster):
    &#34;&#34;&#34;
    Calculate the absolute origins for each line incident to this cluster

    This is calculated by sorting the other endpoints and &#34;empirically&#34; set them
    one after the other around the center.
    &#34;&#34;&#34;
    incomings = list(source_cluster.incoming.items())
    incomings.sort(key=lambda x: x[0].rank)
    outgoings = list(source_cluster.outgoing.items())
    outgoings.sort(key=lambda x: x[0].rank)

    # The key is a pair of (source, target)
    # The value is the y coordinate of where the endpoint in source should originate.
    pairs = {}

    # Space to leave between each line
    line_separation = self.line_width * self.line_spacing

    # We calculate around the center of the cluster, so this is the offset to start at
    half_in_width = (source_cluster.insize * self.line_width + line_separation * (len(incomings) - 1)) / 2.

    # source_cluster.y refers to the center of the cluster, so subtract half the width such that the center align
    cumulative = source_cluster.y - half_in_width
    for (target_cluster, members) in incomings:
        thickness = len(members) * self.line_width
        pairs[(source_cluster, target_cluster)] = cumulative + thickness / 2.
        cumulative += thickness + line_separation

    # We calculate around the center of the cluster, so this is the offset to start at
    half_out_width = (source_cluster.outsize * self.line_width + line_separation * (len(outgoings) - 1)) / 2.

    # source_cluster.y refers to the center of the cluster, so subtract half the width such that the center align
    cumulative = source_cluster.y - half_out_width
    for (target_cluster, members) in outgoings:
        thickness = len(members) * self.line_width
        pairs[(source_cluster, target_cluster)] = cumulative + thickness / 2.
        cumulative += thickness + line_separation

    return pairs</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.center_distance"><code class="name flex">
<span>def <span class="ident">center_distance</span></span>(<span>self, u:<a title="tgv.layout.SizedConnectionCluster" href="#tgv.layout.SizedConnectionCluster">SizedConnectionCluster</a>, v:<a title="tgv.layout.SizedConnectionCluster" href="#tgv.layout.SizedConnectionCluster">SizedConnectionCluster</a>, non_connectedness_factor=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the distance between the centers of two cluster if they were to be adjacent</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>u</code></strong></dt>
<dd><p>Cluster</p></dd>
<dt><strong><code>v</code></strong></dt>
<dd><p>Cluster</p></dd>
<dt><strong><code>non_connectedness_factor</code></strong></dt>
<dd><p>Factor by which to increase the distance if the clusters do not share neighbors</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def center_distance(self, u: SizedConnectionCluster, v: SizedConnectionCluster, non_connectedness_factor=1.):
    &#34;&#34;&#34;
    Calculate the distance between the centers of two cluster if they were to be adjacent

    :param u: Cluster
    :param v: Cluster
    :param non_connectedness_factor: Factor by which to increase the distance if the clusters do not share neighbors
    &#34;&#34;&#34;
    if non_connectedness_factor != 1. and self.num_shared_neighbours(u, v) == 0:
        return self.yseparation * non_connectedness_factor + (u.draw_size + v.draw_size) / 2.
    return self.yseparation + (u.draw_size + v.draw_size) / 2.</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.check_locations"><code class="name flex">
<span>def <span class="ident">check_locations</span></span>(<span>self, excepting=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether the determined locations are consistent with the determined ordering</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>excepting</code></strong></dt>
<dd><p>Whether to raise an exception if the locations are inconsistent</p></dd>
</dl>
<h2 id="returns">Returns:</h2>
<dl>
<dd></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_locations(self, excepting=True):
    &#34;&#34;&#34;
    Check whether the determined locations are consistent with the determined ordering

    :param excepting: Whether to raise an exception if the locations are inconsistent
    :return:
    &#34;&#34;&#34;
    for order in self.ordered:
        prev = -1
        for cluster in order:
            if cluster.y &lt;= prev:
                if excepting:
                    raise UnorderedException(
                        f&#34;Locations are not in order of ranks: {cluster} is higher than {self.pred(cluster)}&#34;)
                else:
                    print(f&#34;{cluster} is higher than {self.pred(cluster)}&#34;)
            prev = cluster.y</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.collapse_stairs_iteration"><code class="name flex">
<span>def <span class="ident">collapse_stairs_iteration</span></span>(<span>self, minimum_want=3, allowed_extra_crossings=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Mitigates the staircase effect on connected parts of the graph</p>
<p>The goal is to move shorter chains closer to their desired position. Shorter chains have a better chance to
fit tightly as opposed to longer chains.
For every two adjacent alignments, it is always that either root is a predecessor or successor to a cluster
in the other alignment. As such we only need to check the roots, but we have to check both the direction this
alignment wants to go and the direction the predecessor alignment and successor alignment of the root want to go
We first establish the desired direction of each alignment in its root. Then for each root we check 4 cases:
case 1: this alignment wants to go up
case 2: this alignment wants to go down
case 3: the successor wants to go up
case 4: the predecessor wants to go down
These cases are mutually exclusive, even though case 1 and 4 cause the same swap, as do 2 and 3.
Preference is given to case 1 and 2. It is a possibility that both case 3 and 4 are valid, but after execution
of either case, the other will be obstructed, because the predecessor and successor change. Cases are looped
until a stop condition is reached. In short for a swap to occur the following things must hold:
a. in case 1 and 2, this chain must be shorter than the predecessor/successor. For case 3 and 4 this is inverted
b. the shorter chain must move in its desired direction, updated after every step.
A direction value between 2 and -2 (inclusive) is optimal and is treated as no desired direction.
c. the alignments must be fully adjacent (ask me if this requirement is unclear)
d. the swap may not increase the amount of crossings in the graph more than a certain amount (default: 0)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collapse_stairs_iteration(self, minimum_want=3, allowed_extra_crossings=0):
    &#34;&#34;&#34;
    Mitigates the staircase effect on connected parts of the graph

    The goal is to move shorter chains closer to their desired position. Shorter chains have a better chance to
    fit tightly as opposed to longer chains.
    For every two adjacent alignments, it is always that either root is a predecessor or successor to a cluster
    in the other alignment. As such we only need to check the roots, but we have to check both the direction this
    alignment wants to go and the direction the predecessor alignment and successor alignment of the root want to go
    We first establish the desired direction of each alignment in its root. Then for each root we check 4 cases:
    case 1: this alignment wants to go up
    case 2: this alignment wants to go down
    case 3: the successor wants to go up
    case 4: the predecessor wants to go down
    These cases are mutually exclusive, even though case 1 and 4 cause the same swap, as do 2 and 3.
    Preference is given to case 1 and 2. It is a possibility that both case 3 and 4 are valid, but after execution
    of either case, the other will be obstructed, because the predecessor and successor change. Cases are looped
    until a stop condition is reached. In short for a swap to occur the following things must hold:
    a. in case 1 and 2, this chain must be shorter than the predecessor/successor. For case 3 and 4 this is inverted
    b. the shorter chain must move in its desired direction, updated after every step.
        A direction value between 2 and -2 (inclusive) is optimal and is treated as no desired direction.
    c. the alignments must be fully adjacent (ask me if this requirement is unclear)
    d. the swap may not increase the amount of crossings in the graph more than a certain amount (default: 0)
    &#34;&#34;&#34;
    for cluster in self.clusters:
        if cluster.root != cluster:
            continue
        cluster.update_wanted_direction()

    for cluster in self.clusters:
        if cluster.root != cluster:
            continue

        successor = self.succ(cluster)
        predecessor = self.pred(cluster)

        # Case 1
        while (cluster.wanted_direction &lt;= -minimum_want
               and predecessor is not None and predecessor.root.chain_length &gt; cluster.chain_length
               and self.adjacent_alignments(predecessor, cluster)
               and self.crossing_diff_if_swapped_align(predecessor, cluster) &lt;= allowed_extra_crossings):
            self.swap_align(predecessor, cluster)
            predecessor.root.update_wanted_direction()
            cluster.update_wanted_direction()
            predecessor = self.pred(cluster)

        # Case 2
        while (cluster.wanted_direction &gt;= minimum_want
               and successor is not None and successor.root.chain_length &gt; cluster.chain_length
               and self.adjacent_alignments(cluster, successor)
               and self.crossing_diff_if_swapped_align(cluster, successor) &lt;= allowed_extra_crossings):
            self.swap_align(cluster, successor)
            successor.root.update_wanted_direction()
            cluster.update_wanted_direction()
            successor = self.succ(cluster)

        # Case 3
        while (successor is not None and successor.root.chain_length &lt;= cluster.chain_length
               and successor.root.wanted_direction &lt; -minimum_want
               and self.adjacent_alignments(cluster, successor)
               and self.crossing_diff_if_swapped_align(cluster, successor) &lt;= allowed_extra_crossings):
            self.swap_align(cluster, successor)
            successor.root.update_wanted_direction()
            cluster.update_wanted_direction()
            successor = self.succ(cluster)

        # Case 4
        while (predecessor is not None and predecessor.root.chain_length &lt; cluster.chain_length
               and predecessor.root.wanted_direction &gt;= minimum_want
               and self.adjacent_alignments(predecessor, cluster)
               and self.crossing_diff_if_swapped_align(predecessor, cluster) &lt;= allowed_extra_crossings):
            self.swap_align(predecessor, cluster)
            predecessor.root.update_wanted_direction()
            cluster.update_wanted_direction()
            predecessor = self.pred(cluster)</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.crossing_diff_if_swapped"><code class="name flex">
<span>def <span class="ident">crossing_diff_if_swapped</span></span>(<span>self, cluster1:<a title="tgv.layout.SizedConnectionCluster" href="#tgv.layout.SizedConnectionCluster">SizedConnectionCluster</a>, cluster2:<a title="tgv.layout.SizedConnectionCluster" href="#tgv.layout.SizedConnectionCluster">SizedConnectionCluster</a>) >int</span>
</code></dt>
<dd>
<div class="desc"><p>Determine the relative difference in crossings if we were to swap the rank of these clusters.</p>
<p>The clusters should be of the same layer.</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>cluster1</code></strong></dt>
<dd><p>One cluster</p></dd>
<dt><strong><code>cluster2</code></strong></dt>
<dd><p>The other cluster</p></dd>
</dl>
<h2 id="returns">Returns:</h2>
<dl>
<dd><p>The relative difference. Negative indicates a decrease in crossings</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crossing_diff_if_swapped(self, cluster1: SizedConnectionCluster, cluster2: SizedConnectionCluster) -&gt; int:
    &#34;&#34;&#34;
    Determine the relative difference in crossings if we were to swap the rank of these clusters.

    The clusters should be of the same layer.

    :param cluster1: One cluster
    :param cluster2: The other cluster
    :return: The relative difference. Negative indicates a decrease in crossings
    &#34;&#34;&#34;
    if cluster1.rank &gt; cluster2.rank:
        upper, lower = cluster2, cluster1
    else:
        upper, lower = cluster1, cluster2
    return self.get_num_crossings(lower, upper) - self.get_num_crossings(upper, lower)</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.crossing_diff_if_swapped_align"><code class="name flex">
<span>def <span class="ident">crossing_diff_if_swapped_align</span></span>(<span>self, upper:<a title="tgv.layout.SizedConnectionCluster" href="#tgv.layout.SizedConnectionCluster">SizedConnectionCluster</a>, lower:<a title="tgv.layout.SizedConnectionCluster" href="#tgv.layout.SizedConnectionCluster">SizedConnectionCluster</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Count the amount of extra crossings this swap would cause. upper and lower should be in adjacent alignments</p>
<p>Function works by swapping each element and summing the individual differences in crossings</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>upper</code></strong></dt>
<dd><p>cluster in the upper (lower rank) alignment</p></dd>
<dt><strong><code>lower</code></strong></dt>
<dd><p>Cluster in the lower (higher rank) alignment</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crossing_diff_if_swapped_align(self, upper: SizedConnectionCluster, lower: SizedConnectionCluster):
    &#34;&#34;&#34;
    Count the amount of extra crossings this swap would cause. upper and lower should be in adjacent alignments

    Function works by swapping each element and summing the individual differences in crossings

    :param upper: cluster in the upper (lower rank) alignment
    :param lower: Cluster in the lower (higher rank) alignment
    &#34;&#34;&#34;
    uroot = upper.root
    lroot = lower.root
    cluster = lroot
    crossing_diff = 0
    length = 0
    while True:
        predecessor = self.pred(cluster)
        if predecessor is not None and predecessor.root == uroot:
            crossing_diff += self.crossing_diff_if_swapped(cluster, predecessor)
            length += 1
        cluster = cluster.align
        if cluster == lroot:
            break
    return crossing_diff - 2 * (length - 1)</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.draw_clusters"><code class="name flex">
<span>def <span class="ident">draw_clusters</span></span>(<span>self, context:cairo.Context) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a surface with all cluster drawn on them to be overlaid on the connection surface
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_clusters(self, context: cairo.Context) -&gt; None:
    &#34;&#34;&#34;
    Returns a surface with all cluster drawn on them to be overlaid on the connection surface
    :return:
    &#34;&#34;&#34;
    (r, g, b, a) = self.default_cluster_color

    context.set_line_width(self.cluster_width)
    context.set_source_rgba(r, g, b, a)

    for cluster in self.clusters:
        cx, cy = cluster.pos()
        context.move_to(cx, cy - cluster.draw_size / 2.)
        context.line_to(cx, cy + cluster.draw_size / 2.)
        context.stroke()</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.draw_connections"><code class="name flex">
<span>def <span class="ident">draw_connections</span></span>(<span>self, context:cairo.Context, colormap:dict, show_annotations:bool, fading:bool) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a cairo surface with just the connections drawn onto them.</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>colormap</code></strong></dt>
<dd><p>dictionary that converts a node name to a color value</p></dd>
<dt><strong><code>show_annotations</code></strong></dt>
<dd><p>Flag to show additional information per connection</p></dd>
<dt><strong><code>fading</code></strong></dt>
<dd><p>Flag to also draw the fade in and out connections per cluster</p></dd>
</dl>
<h2 id="returns">Returns:</h2>
<dl>
<dd><p>cairo surface with connections</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_connections(self, context: cairo.Context, colormap: dict, show_annotations: bool, fading: bool) -&gt; None:
    &#34;&#34;&#34;
    Returns a cairo surface with just the connections drawn onto them.

    :param colormap: dictionary that converts a node name to a color value
    :param show_annotations: Flag to show additional information per connection
    :param fading: Flag to also draw the fade in and out connections per cluster
    :return: cairo surface with connections
    &#34;&#34;&#34;

    line_coordinates = dict()  # k: (source, target), v: y-coordinate of endpoint in source.

    for cluster in self.clusters:
        line_coordinates.update(self.calculate_line_origins(cluster))

    if fading:
        for cluster in self.clusters:
            if cluster.insize == 0:
                self.fade_cluster(context, cluster, colormap, direction=INCOMING)
            if cluster.outsize == 0:
                self.fade_cluster(context, cluster, colormap, direction=OUTGOING)

    already_drawn = set()

    for (source, target) in line_coordinates.keys():
        if (target, source) in already_drawn:
            continue

        self.draw_line(source, target, line_coordinates, colormap, context, show_annotations=show_annotations)
        # self.draw_line_monochrome(source, target, line_coordinates, context)

        already_drawn.add((source, target))
        already_drawn.add((target, source))</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.draw_debug"><code class="name flex">
<span>def <span class="ident">draw_debug</span></span>(<span>self, context:cairo.Context, debug_info:Set[str]) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Surface that shows invasive debug information per connection or cluster.</p>
<p>Accepts:
'swap_above': the relative difference in crossings if a cluster was to be swapped with the cluster above it
'ranks': Show the in and out rank information as calculated by the barycenter procedure.
'id': Show the layer and id of a cluster.</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>debug_info</code></strong></dt>
<dd><p>List of debug items to show.</p></dd>
</dl>
<h2 id="returns">Returns:</h2>
<dl>
<dd><p>cairo Surface with debug information</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_debug(self, context: cairo.Context, debug_info: Set[str]) -&gt; None:
    &#34;&#34;&#34;
    Surface that shows invasive debug information per connection or cluster.

    Accepts:
    &#39;swap_above&#39;: the relative difference in crossings if a cluster was to be swapped with the cluster above it
    &#39;ranks&#39;: Show the in and out rank information as calculated by the barycenter procedure.
    &#39;id&#39;: Show the layer and id of a cluster.

    :param debug_info: List of debug items to show.
    :return: cairo Surface with debug information
    &#34;&#34;&#34;
    context.set_source_rgb(0.2, 0.2, 0.2)
    context.select_font_face(&#34;Helvetica&#34;, cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_NORMAL)
    context.set_font_size(self.font_size * 0.2)

    for cluster in self.clusters:
        cx, cy = cluster.pos()
        if cluster.root == cluster:
            if &#34;swap_above&#34; in debug_info:
                context.move_to(cx + self.xseparation * 0.1, cy)
                context.show_text(
                    f&#34;{self.crossing_diff_if_swapped_align(self.pred(cluster), cluster) if self.pred(cluster) is not None else 0:.2f}&#34;)

        if &#34;ranks&#34; in debug_info:
            context.move_to(cx + self.xseparation * 0.1, cy)
            context.show_text(f&#34;{cluster.outrank:.2f}&#34;)
            context.move_to(cx - self.xseparation * 0.3, cy)
            context.show_text(f&#34;{cluster.inrank:.2f}&#34;)

        if &#34;id&#34; in debug_info:
            context.move_to(cx + self.xseparation * 0.1, cy)
            context.show_text(f&#34;{cluster.tc.id}&#34;)
            context.move_to(cx - self.xseparation * 0.3, cy)
            context.show_text(f&#34;{cluster.tc.layer}&#34;)</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.draw_graph"><code class="name flex">
<span>def <span class="ident">draw_graph</span></span>(<span>self, filename:str='output/example.svg', colormap=None, show_timestamps=True, timestamp_translator=None, show_annotations=False, debug_info=None, stats_info=None, fading=False, scale=1.0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_graph(self, filename: str = &#34;output/example.svg&#34;,
               colormap=None,
               show_timestamps=True, timestamp_translator=None,
               show_annotations=False, debug_info=None, stats_info=None,
               fading=False, scale=1.):

    if colormap is None:
        colormap = dict()

    if timestamp_translator is None:
        timestamp_translator = dict()

    # Instead of passing on dozens of parameters, this checks if the user has already called the necessary functions
    # if not, it is called with the default parameters
    if not self.is_located:
        self.set_locations()

    canvaswidth = self.width
    canvasheight = self.height
    if show_timestamps:
        timeheight = self.get_timestamp_height(timestamp_translator) + self.ymargin
        canvasheight += timeheight

    if stats_info is not None:
        canvasheight += self.get_stat_height(stats_info, 200) + self.ymargin

    surface = cairo.SVGSurface(filename, canvaswidth * scale, canvasheight * scale)
    context = cairo.Context(surface)
    context.scale(scale, scale)

    self.draw_connections(context, colormap, show_annotations, fading)
    self.draw_clusters(context)
    if debug_info is not None:
        self.draw_debug(context, debug_info)
    context.translate(0, self.height)
    # offset = self.height + 2*self.ymargin
    if show_timestamps:
        self.draw_timestamps(context, timestamp_translator)
        context.translate(0, timeheight)
    if stats_info is not None:
        self.draw_stats(context, stats_info)

    surface.flush()
    surface.finish()</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.draw_line"><code class="name flex">
<span>def <span class="ident">draw_line</span></span>(<span>self, source:<a title="tgv.layout.SizedConnectionCluster" href="#tgv.layout.SizedConnectionCluster">SizedConnectionCluster</a>, target:<a title="tgv.layout.SizedConnectionCluster" href="#tgv.layout.SizedConnectionCluster">SizedConnectionCluster</a>, line_coordinates:dict, colormap:dict, context:cairo.Context, show_annotations=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the connection between source and target with label colors</p>
<p>The line is divided in sections according to the labels of the nodes in this connection.
For each unique label a line is drawn in the associated color with exact offset as to seem one single cohesive</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>source</code></strong></dt>
<dd><p>One endpoint of the line</p></dd>
<dt><strong><code>target</code></strong></dt>
<dd><p>The other endpoint of the line</p></dd>
<dt><strong><code>line_coordinates</code></strong></dt>
<dd><p>Dictionary with absolute coordinates of the endpoints</p></dd>
<dt><strong><code>colormap</code></strong></dt>
<dd><p>Dictionary with label names and associated colors</p></dd>
<dt><strong><code>context</code></strong></dt>
<dd><p>cairo context to draw this line on</p></dd>
<dt><strong><code>show_annotations</code></strong></dt>
<dd><p>provides annotations when a line changes size significantly</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_line(self, source: SizedConnectionCluster, target: SizedConnectionCluster,
              line_coordinates: dict, colormap: dict,
              context: cairo.Context,
              show_annotations=False):
    &#34;&#34;&#34;
    Draws the connection between source and target with label colors

    The line is divided in sections according to the labels of the nodes in this connection.
    For each unique label a line is drawn in the associated color with exact offset as to seem one single cohesive

    :param source: One endpoint of the line
    :param target: The other endpoint of the line
    :param line_coordinates: Dictionary with absolute coordinates of the endpoints
    :param colormap: Dictionary with label names and associated colors
    :param context: cairo context to draw this line on
    :param show_annotations: provides annotations when a line changes size significantly
    &#34;&#34;&#34;
    members = source.neighbours[target]
    num_members = len(members)
    thickness = num_members * self.line_width
    half_thickness = len(members) * self.line_width / 2.

    labels = Counter(map(lambda x: x.meta_string, members))
    labels = [(colormap.get(lbl, self.default_line_color), cnt / num_members) for (lbl, cnt) in
              sorted(list(labels.items()))]

    y_source = line_coordinates[(source, target)]
    y_target = line_coordinates[(target, source)]
    context.save()
    context.rectangle(source.x, 0, target.x, self.height)
    context.clip()

    if len(labels) == 1:
        (r, g, b, a) = labels[0][0]
        context.set_source_rgba(r, g, b, a)
        context.set_line_width(thickness)
        context.move_to(source.x, y_source)
        context.curve_to(source.x + self.curve_offset, y_source,
                         target.x - self.curve_offset, y_target,
                         target.x, y_target)

        context.stroke()

    else:
        coloured_bezier(context,
                        (source.x, y_source),
                        (source.x + self.curve_offset, y_source),
                        (target.x - self.curve_offset, y_target),
                        (target.x, y_target),
                        labels,
                        thickness,
                        detail=min(100, max(4, int(abs(y_target - y_source) * self.line_width))))

    if show_annotations:
        # draw some annotatations of the bundle size
        context.set_source_rgb(0, 0, 0)
        context.select_font_face(&#34;Helvetica&#34;, cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_NORMAL)
        context.set_font_size(min(self.line_width * len(members), self.xseparation * 0.7))  # in user space units

        if len(members) &gt;= 1.5 * max(map(len, source.incoming.values()), default=0.):
            to_print = str(len(members))
            _, _, width, height, _, _ = context.text_extents(to_print)
            context.move_to(source.x + self.xseparation / 2 - width / 2,
                            (y_source + y_target) / 2 + height / 2)
            context.show_text(to_print)
            context.stroke()
    context.restore()</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.draw_stats"><code class="name flex">
<span>def <span class="ident">draw_stats</span></span>(<span>self, context:cairo.Context, data:Collection[str], maxheight:int=200) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a recording surface to be played back with statistics about the graph.</p>
<p>Currently accepted statistic strings are &quot;in_out_difference&quot;, &quot;layer_num_clusters&quot;, &quot;layer_num_members&quot;,
&quot;homogeneity&quot;, &quot;homogeneity_diff&quot;. See for explanations the respective functions in TimeGraph.
Per statistic the height of the drawing is one third of the graph height or maxheight, whichever is lower.</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>maxheight</code></strong></dt>
<dd><p>Maximum height in points of per statistic</p></dd>
<dt><strong><code>data</code></strong></dt>
<dd><p>Iterable of strings of the statistics to show (in order)</p></dd>
</dl>
<h2 id="returns">Returns:</h2>
<dl>
<dd><p>cairo recording of statistics</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_stats(self, context: cairo.Context, data: Collection[str], maxheight: int = 200) -&gt; None:
    &#34;&#34;&#34;
    Returns a recording surface to be played back with statistics about the graph.

    Currently accepted statistic strings are &#34;in_out_difference&#34;, &#34;layer_num_clusters&#34;, &#34;layer_num_members&#34;,
    &#34;homogeneity&#34;, &#34;homogeneity_diff&#34;. See for explanations the respective functions in TimeGraph.
    Per statistic the height of the drawing is one third of the graph height or maxheight, whichever is lower.

    :param maxheight: Maximum height in points of per statistic
    :param data: Iterable of strings of the statistics to show (in order)
    :return: cairo recording of statistics
    &#34;&#34;&#34;
    h = min(self.height / 3, maxheight)

    marg = 0.1  # Margin around the drawing and in between different stats, in percent of h.

    for i, name in enumerate(data):

        if name == &#34;in_out_difference&#34;:
            d = self.g.layer_in_out_diff()
        elif name == &#34;layer_num_clusters&#34;:
            d = self.g.layer_num_clusters()
        elif name == &#34;layer_num_members&#34;:
            d = self.g.layer_num_members()
        elif name == &#34;homogeneity&#34;:
            d = self.g.relative_continuity()
        elif name == &#34;homogeneity_diff&#34;:
            d = self.g.relative_continuity_diff()
        else:
            print(f&#34;Name {name} not found!&#34;)
            continue

        maxval = max(d)
        scale = (h * (1. - 2 * marg)) / maxval  # Scale of the graph.

        context.set_line_width(h/100)

        # Draw base axes
        context.set_source_rgba(0, 0, 0, 1)
        context.move_to(self.xmargin * 0.95, (i + marg) * h)
        context.line_to(self.xmargin * 0.9, (i + marg) * h)
        context.line_to(self.xmargin * 0.9, (i + 1. - marg) * h)
        context.line_to(self.width - self.xmargin, (i + 1. - marg) * h)
        context.stroke()

        # Show top value (bottom is always 0)
        text_to_show = f&#34;{maxval:.2f}&#34;
        context.select_font_face(&#34;Helvetica&#34;, cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_NORMAL)
        context.set_font_size(min(self.font_size * 0.4, h / 10))
        _, _, tw, th, _, _ = context.text_extents(text_to_show)
        context.move_to(self.xmargin * 0.85 - tw, (i + marg) * h + th)
        context.show_text(text_to_show)

        # Draw line of average
        avg = sum(d) / len(d)
        context.set_source_rgba(0, 1, 0, 1)
        context.move_to(self.xmargin, (i + marg) * h + (maxval - avg) * scale)
        context.line_to(self.width - self.xmargin, (i + marg) * h + (maxval - avg) * scale)
        context.stroke()

        # Draw data
        context.set_source_rgba(0, 0, 1, 1)
        context.move_to(self.xmargin, (i + marg) * h + (maxval - d[0]) * scale)
        for j in range(1, len(d)):
            context.line_to(self.xmargin + j * self.xseparation, (i + marg) * h + (maxval - d[j]) * scale)

        context.stroke()

        # Show additional information in text
        streak, crossings = self.streak_no_cross(d, avg)
        text_to_show = f&#34;{name}: avg ({avg:.3f}), streak ({streak}), crossings ({crossings}), cross_percent ({(crossings / len(d)):2f})&#34;

        context.set_font_size(min(self.font_size * 0.5, h / 8))
        _, _, tw, th, _, _ = context.text_extents(text_to_show)
        context.move_to(0.3 * self.xseparation + self.xmargin, (i + marg) * h + th)
        context.show_text(text_to_show)</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.draw_timestamps"><code class="name flex">
<span>def <span class="ident">draw_timestamps</span></span>(<span>self, context:cairo.Context, timestamp_translator) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Separate surface that the timestamps are drawn onto.</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>timestamp_translator</code></strong></dt>
<dd><p>Object that converts a layer number to a layer identifier</p></dd>
</dl>
<h2 id="returns">Returns:</h2>
<dl>
<dd><p>Surface with drawn timestamps in the same offsets as the layers.</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_timestamps(self, context: cairo.Context, timestamp_translator) -&gt; None:
    &#34;&#34;&#34;
    Separate surface that the timestamps are drawn onto.

    :param timestamp_translator: Object that converts a layer number to a layer identifier
    :return: Surface with drawn timestamps in the same offsets as the layers.
    &#34;&#34;&#34;

    context.set_source_rgb(0, 0, 0)
    context.select_font_face(&#34;Helvetica&#34;, cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_NORMAL)
    context.set_font_size(self.font_size)  # in user space units # self.xseparation * 0.6

    for t in range(self.num_layers):
        context.move_to(self.xmargin + t * self.xseparation, 0)
        context.line_to(self.xmargin + t * self.xseparation, self.xseparation * 0.2)

        to_print = str(t)
        if timestamp_translator:
            to_print = timestamp_translator[t]

        _, _, width, height, _, _ = context.text_extents(to_print)

        context.move_to(self.xmargin + t * self.xseparation + height / 2,
                        width + self.xseparation * 0.3)

        context.save()
        context.rotate(math.radians(270))  # angle in rad
        context.show_text(to_print)
        context.restore()

    context.stroke()</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.fade_cluster"><code class="name flex">
<span>def <span class="ident">fade_cluster</span></span>(<span>self, context:cairo.Context, cluster:<a title="tgv.layout.SizedConnectionCluster" href="#tgv.layout.SizedConnectionCluster">SizedConnectionCluster</a>, colormap:Dict, direction)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw a fading line into or from a certain cluster.</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>context</code></strong></dt>
<dd><p>cairo Context to draw on</p></dd>
<dt><strong><code>cluster</code></strong></dt>
<dd><p>Cluster to use as source</p></dd>
<dt><strong><code>colormap</code></strong></dt>
<dd><p>map of coloring for the names of the nodes in the cluster</p></dd>
<dt><strong><code>direction</code></strong></dt>
<dd><p>True for a fade in, False for a fade out</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fade_cluster(self, context: cairo.Context, cluster: SizedConnectionCluster, colormap: Dict, direction):
    &#34;&#34;&#34;
    Draw a fading line into or from a certain cluster.

    :param context: cairo Context to draw on
    :param cluster: Cluster to use as source
    :param colormap: map of coloring for the names of the nodes in the cluster
    :param direction: True for a fade in, False for a fade out
    &#34;&#34;&#34;
    colors = [(colormap.get(lbl, self.default_line_color), cnt / len(cluster)) for (lbl, cnt) in
              sorted(list(Counter(map(lambda x: x.meta_string, cluster.members)).items()))]
    if direction:
        coloured_bezier(context,
                        (cluster.x - self.xseparation / 3., cluster.y),
                        (cluster.x, cluster.y),
                        (cluster.x, cluster.y),
                        (cluster.x, cluster.y),
                        colors=colors, width=self.line_width * len(cluster), detail=4, fade=&#39;in&#39;)
    else:
        coloured_bezier(context,
                        (cluster.x, cluster.y),
                        (cluster.x, cluster.y),
                        (cluster.x, cluster.y),
                        (cluster.x + self.xseparation / 3., cluster.y),
                        colors=colors, width=self.line_width * len(cluster), detail=4, fade=&#39;out&#39;)</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.get_stat_height"><code class="name flex">
<span>def <span class="ident">get_stat_height</span></span>(<span>self, stat_info, maxheight)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_stat_height(self, stat_info, maxheight):
    return min(self.height / 3, maxheight) * len(stat_info)</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.get_timestamp_height"><code class="name flex">
<span>def <span class="ident">get_timestamp_height</span></span>(<span>self, timestamp_translator)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_timestamp_height(self, timestamp_translator):
    tmpsurf = cairo.RecordingSurface(cairo.CONTENT_COLOR_ALPHA, None)
    context = cairo.Context(tmpsurf)
    context.select_font_face(&#34;Helvetica&#34;, cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_NORMAL)
    context.set_font_size(self.font_size)

    h = max([context.text_extents(timestamp_translator.get(t, str(t)))[2] for t in range(self.num_layers)]) + 0.3*self.xseparation
    tmpsurf.finish()
    return h</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.has_larger_crossings"><code class="name flex">
<span>def <span class="ident">has_larger_crossings</span></span>(<span>self, start_cluster, until_rank, connection_size)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks for crossing of at least a certain size until it is found or a certain rank is reached</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>start_cluster</code></strong></dt>
<dd><p>First cluster to check connections from. Should have a lower rank than until_rank</p></dd>
<dt><strong><code>until_rank</code></strong></dt>
<dd><p>Continue up to and including the cluster of this rank.</p></dd>
<dt><strong><code>connection_size</code></strong></dt>
<dd><p>Threshold for which to check.</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_larger_crossings(self, start_cluster, until_rank, connection_size):
    &#34;&#34;&#34;
    Checks for crossing of at least a certain size until it is found or a certain rank is reached

    :param start_cluster: First cluster to check connections from. Should have a lower rank than until_rank
    :param until_rank: Continue up to and including the cluster of this rank.
    :param connection_size: Threshold for which to check.
    &#34;&#34;&#34;
    cluster = start_cluster
    while cluster is not None and cluster.rank &lt;= until_rank:
        if cluster.align != cluster.root and len(cluster.neighbours[cluster.align]) &gt; connection_size:
            return True
        cluster = self.succ(cluster)
    return False</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.place_block"><code class="name flex">
<span>def <span class="ident">place_block</span></span>(<span>self, root)</span>
</code></dt>
<dd>
<div class="desc"><p>Place an aligned section by placing all blocks above it and then fitting it as high as possible</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>root</code></strong></dt>
<dd><p>Root of the alignment to place</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def place_block(self, root):
    &#34;&#34;&#34;
    Place an aligned section by placing all blocks above it and then fitting it as high as possible

    :param root: Root of the alignment to place
    &#34;&#34;&#34;

    # If block was already placed, skip
    if root._y &lt; 0.:
        root._y = 0.
        cluster = root

        while True:
            if cluster.rank &gt; 0:
                predecessor = self.pred(cluster)
                self.place_block(predecessor.root)

                root._y = max(root._y, predecessor.root._y + self.center_distance(predecessor, cluster))

            cluster = cluster.align
            if cluster == root:
                break</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.pred"><code class="name flex">
<span>def <span class="ident">pred</span></span>(<span>self, c:<a title="tgv.layout.SizedConnectionCluster" href="#tgv.layout.SizedConnectionCluster">SizedConnectionCluster</a>) >Optional[<a title="tgv.layout.SizedConnectionCluster" href="#tgv.layout.SizedConnectionCluster">SizedConnectionCluster</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the predecessor of this cluster (e.g. the cluster with rank-1)</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>c</code></strong></dt>
<dd><p>Cluster to find the predecessor of</p></dd>
</dl>
<h2 id="returns">Returns:</h2>
<dl>
<dd><p>SugiyamaCluster or None if no predecessor exists</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pred(self, c: SizedConnectionCluster) -&gt; Optional[SizedConnectionCluster]:
    &#34;&#34;&#34;
    Returns the predecessor of this cluster (e.g. the cluster with rank-1)
    
    :param c: Cluster to find the predecessor of
    :return: SugiyamaCluster or None if no predecessor exists
    &#34;&#34;&#34;
    if c.rank == 0:
        return None
    return self.ordered[c.tc.layer][c.rank - 1]</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.remove_alignments"><code class="name flex">
<span>def <span class="ident">remove_alignments</span></span>(<span>self, start_cluster:<a title="tgv.layout.SizedConnectionCluster" href="#tgv.layout.SizedConnectionCluster">SizedConnectionCluster</a>, until_rank:int)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes all alignments of clusters from start_cluster until a certain rank is reached</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>start_cluster</code></strong></dt>
<dd><p>first cluster to remove alignment from. Should have a lower rank than until_rank</p></dd>
<dt><strong><code>until_rank</code></strong></dt>
<dd><p>continue up to and including the cluster of this rank.</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_alignments(self, start_cluster: SizedConnectionCluster, until_rank: int):
    &#34;&#34;&#34;
    Removes all alignments of clusters from start_cluster until a certain rank is reached

    :param start_cluster: first cluster to remove alignment from. Should have a lower rank than until_rank
    :param until_rank: continue up to and including the cluster of this rank.
    &#34;&#34;&#34;
    cluster = start_cluster
    while cluster is not None and cluster.rank &lt;= until_rank:
        if cluster.align != cluster.root:  # cluster must not be an endpoint
            cluster.align.reset_alignment()
            cluster.reset_endpoint()
        cluster = self.succ(cluster)</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.reset_alignments"><code class="name flex">
<span>def <span class="ident">reset_alignments</span></span>(<span>self) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Reset all alignment values and flag all subsequent steps to be out of date.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_alignments(self) -&gt; None:
    &#34;&#34;&#34;
    Reset all alignment values and flag all subsequent steps to be out of date.
    &#34;&#34;&#34;
    for cluster in self.clusters:
        cluster.reset_alignment()
    self.is_aligned = False
    self.is_located = False</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.reset_order"><code class="name flex">
<span>def <span class="ident">reset_order</span></span>(<span>self) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Reset the ordering properties of this graph and invalidate successive steps done with previous ordering.</p>
<p>Clusters are first reset to the position in the original graph and then sorted by supercluster as a base case.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_order(self) -&gt; None:
    &#34;&#34;&#34;
    Reset the ordering properties of this graph and invalidate successive steps done with previous ordering.

    Clusters are first reset to the position in the original graph and then sorted by supercluster as a base case.
    &#34;&#34;&#34;
    self.ordered = [self.layers[t].copy() for t in range(self.num_layers)]
    for layer in self.ordered:
        for i, cluster in enumerate(layer):
            cluster.rank = i
    self.sort_by_supercluster()
    self.is_ordered = False
    self.is_aligned = False
    self.is_located = False</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.set_alignment"><code class="name flex">
<span>def <span class="ident">set_alignment</span></span>(<span>self, direction_flag=True, max_chain=-1, max_inout_diff=2.0, stairs_iterations=2) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Align clusters to be of the same chain to improved readability of the Graph.</p>
<p>Clusters try to be chained with their median largest incoming connection. A chain is a sequence of clusters
in successive layers that will all be placed at the same vertical coordinate. If two chains intersect
at a point, the largest connection is given priority and the other chain is broken. If a cluster cannot
align with its median largest cluster it will not try for other options.
After chains are formed, the function will try to reduce staircasing by swapping clusters around.</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>direction_flag</code></strong></dt>
<dd><p>switch between aligning from left to right (forward) or right to left (backward)</p></dd>
<dt><strong><code>max_chain</code></strong></dt>
<dd><p>Maximum length a chain is allowed, or -1 if a chain can be arbitrarily long</p></dd>
<dt><strong><code>max_inout_diff</code></strong></dt>
<dd><p>Factor to prevent chains from forming when the difference between the largest incoming</p></dd>
</dl>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<span class="docutils literal">&lt;string&gt;</span>, line 12)</p>
<p>Field list ends without a blank line; unexpected unindent.</p>
</div>
<p>and largest outgoing connection is too big. A factor of two will prevent aligning the cluster if the largest
outgoing connection is more than twice as large as its largest incoming. This prevents overenthousiastic
alignments that make little sense. -1 for no limit
:param stairs_iterations: The amount of iterations for the anti-staircase function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_alignment(self, direction_flag=FORWARD, max_chain=-1, max_inout_diff=2., stairs_iterations=2) -&gt; None:
    &#34;&#34;&#34;
    Align clusters to be of the same chain to improved readability of the Graph.

    Clusters try to be chained with their median largest incoming connection. A chain is a sequence of clusters
    in successive layers that will all be placed at the same vertical coordinate. If two chains intersect
    at a point, the largest connection is given priority and the other chain is broken. If a cluster cannot
    align with its median largest cluster it will not try for other options.
    After chains are formed, the function will try to reduce staircasing by swapping clusters around.

    :param direction_flag: switch between aligning from left to right (forward) or right to left (backward)
    :param max_chain: Maximum length a chain is allowed, or -1 if a chain can be arbitrarily long
    :param max_inout_diff: Factor to prevent chains from forming when the difference between the largest incoming
    and largest outgoing connection is too big. A factor of two will prevent aligning the cluster if the largest
    outgoing connection is more than twice as large as its largest incoming. This prevents overenthousiastic
    alignments that make little sense. -1 for no limit
    :param stairs_iterations: The amount of iterations for the anti-staircase function.
    &#34;&#34;&#34;
    # Instead of passing on dozens of parameters, this checks if the user has already called the necessary functions
    # if not, it is called with the default parameters
    if not self.is_ordered:
        self.set_order()

    if direction_flag:
        layer_range = range(1, self.num_layers)
    else:
        layer_range = range(self.g.num_steps - 2, -1, -1)

    for layer in layer_range:
        r = -1

        for cluster in self.ordered[layer]:
            if (cluster.insize == 0 or
                    (
                            max_inout_diff &gt;= 0. and cluster.largest_outgoing / cluster.largest_incoming &gt; max_inout_diff)):
                continue

            # Find cluster in previous layer this one wants to connect to and the weight of the connection
            wanted, connsize = cluster.largest_median_connection(direction=direction_flag)

            if wanted is not None and (max_chain &lt; 0 or wanted.root.chain_length &lt;= max_chain):

                # Check if this connection contradicts another alignment
                # priority to the new connection is only given if the weight is higher than all crossings
                if wanted.rank &lt;= r:
                    if self.has_larger_crossings(wanted, r, connsize):
                        continue
                    self.remove_alignments(wanted, r)

                wanted.align_with(cluster)
                r = wanted.rank

    for _ in range(stairs_iterations):
        self.collapse_stairs_iteration()

    self.is_aligned = True</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.set_locations"><code class="name flex">
<span>def <span class="ident">set_locations</span></span>(<span>self, averaging_iterations=5) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Place the chains that have been identified and ordered.</p>
<p>Chains are placed as compactly and high as possible initially. This can introduce unneccessary distances,
so this value is treated as an upper bound. After the bounds have been established, chains will try to move as
close to the average position of its connections outside itself below that bound, without moving past the
chain below.</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>averaging_iterations</code></strong></dt>
<dd><p>The amount of times the averaging should be performed, as each iteration changes</p></dd>
</dl>
<div class="system-message">
<p class="system-message-title">System Message: WARNING/2 (<span class="docutils literal">&lt;string&gt;</span>, line 9)</p>
<p>Field list ends without a blank line; unexpected unindent.</p>
</div>
<p>how low a cluster w.r.t. the position change of its successor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_locations(self, averaging_iterations=5) -&gt; None:
    &#34;&#34;&#34;
    Place the chains that have been identified and ordered.

    Chains are placed as compactly and high as possible initially. This can introduce unneccessary distances,
    so this value is treated as an upper bound. After the bounds have been established, chains will try to move as
    close to the average position of its connections outside itself below that bound, without moving past the
    chain below.

    :param averaging_iterations: The amount of times the averaging should be performed, as each iteration changes
    how low a cluster w.r.t. the position change of its successor.
    &#34;&#34;&#34;
    # Instead of passing on dozens of parameters, this checks if the user has already called the necessary functions
    # if not, it is called with the default parameters
    if not self.is_aligned:
        self.set_alignment()

    self.set_x_positions()

    for cluster in self.clusters:
        if cluster.root == cluster:
            self.place_block(cluster)

    self.set_y_positions()

    for _ in range(averaging_iterations):
        for cluster in self.clusters:
            cluster._y = -1.

        for cluster in self.clusters:
            if cluster.root == cluster:
                self.avg_block(cluster)

        self.set_y_positions()

    self.check_locations()
    self.is_located = True</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.set_order"><code class="name flex">
<span>def <span class="ident">set_order</span></span>(<span>self, barycenter_passes:int=10) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Order the clusters in self.ordered with the barycenter method</p>
<p>For each pass of the ordering, the barycenter method is applied once forward and once backward.
After each pass the ordering is checked whether it changed w.r.t. the previous. All passes are independent
So we can abort if they are the same.</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>barycenter_passes</code></strong></dt>
<dd><p>The maximum number of times to repeat the barycenter procedure</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_order(self, barycenter_passes: int = 10) -&gt; None:
    &#34;&#34;&#34;
    Order the clusters in self.ordered with the barycenter method

    For each pass of the ordering, the barycenter method is applied once forward and once backward.
    After each pass the ordering is checked whether it changed w.r.t. the previous. All passes are independent
    So we can abort if they are the same.

    :param barycenter_passes: The maximum number of times to repeat the barycenter procedure
    &#34;&#34;&#34;
    # Make copy to compare if ordering has stabilized
    orders_tmp = [order.copy() for order in self.ordered]

    # Keep doing passes until the maximum number has been reached or the order does no longer change
    for i in range(barycenter_passes):
        # print(f&#34;Pass #{i}&#34;)
        self._barycenter()
        # self._barycenter()

        if orders_tmp == self.ordered:
            # print(&#34;Order stabilized&#34;)
            break

        orders_tmp = [order.copy() for order in self.ordered]

    self.is_ordered = True</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.set_x_positions"><code class="name flex">
<span>def <span class="ident">set_x_positions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update all x positions of all the clusters, as determined by their layer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_x_positions(self):
    &#34;&#34;&#34;
    Update all x positions of all the clusters, as determined by their layer
    &#34;&#34;&#34;
    for cluster in self.clusters:
        cluster.x = self.xmargin + self.xseparation * cluster.tc.layer
    self.width = 2 * self.xmargin + self.xseparation * self.num_layers</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.set_y_positions"><code class="name flex">
<span>def <span class="ident">set_y_positions</span></span>(<span>self) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Update all y positions of all the clusters, as determined by the algorithm. Also trim possible top margin.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_y_positions(self) -&gt; None:
    &#34;&#34;&#34;
    Update all y positions of all the clusters, as determined by the algorithm. Also trim possible top margin.
    &#34;&#34;&#34;
    min_y = min(map(lambda x: x.root._y - x.draw_size / 2., self.clusters))
    for cluster in self.clusters:
        cluster.y = cluster.root._y + self.ymargin - min_y

    self.height = max(map(lambda x: x.root.y + x.draw_size / 2., self.clusters)) + 2*self.ymargin</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.sort_by_supercluster"><code class="name flex">
<span>def <span class="ident">sort_by_supercluster</span></span>(<span>self) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the ranks of clusters to be near other clusters they are connected to</p>
<p>This works by building superclusters with flood fill. In this case we start new superclusters with the
highest unplaced cluster, instead of the leftmost one, because this balances much better</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort_by_supercluster(self) -&gt; None:
    &#34;&#34;&#34;
    Initialize the ranks of clusters to be near other clusters they are connected to

    This works by building superclusters with flood fill. In this case we start new superclusters with the
    highest unplaced cluster, instead of the leftmost one, because this balances much better
    &#34;&#34;&#34;
    pointers = [0] * self.num_layers
    seen = set()
    max_layer_size = max(map(len, self.layers))

    # traverse all clusters top to bottom instead of left to right
    for i in range(max_layer_size):
        for j in range(self.num_layers):
            if i &gt;= len(self.layers[j]) or i &lt; pointers[j]:
                continue
            cluster = self.ordered[j][i]

            if cluster in seen:
                continue
            seen.add(cluster)

            # Start new supercluster and fill it with a flood fill
            supercluster = []

            q = deque()
            q.append(cluster)
            while len(q) &gt; 0:
                current = q.pop()

                supercluster.append(current)
                for nb in current.neighbours:
                    if nb not in seen:
                        q.append(nb)
                        seen.add(nb)

            for scluster in supercluster:
                l = scluster.tc.layer
                self.swap_clusters(scluster, self.ordered[l][pointers[l]])
                pointers[l] += 1</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.streak_below"><code class="name flex">
<span>def <span class="ident">streak_below</span></span>(<span>self, data:List[Number], num:Number) >int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the longest streak that the data points are below some threshold.</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd><p>Data to analyse</p></dd>
<dt><strong><code>num</code></strong></dt>
<dd><p>Threshold value</p></dd>
</dl>
<h2 id="returns">Returns:</h2>
<dl>
<dd><p>Largest count of consecutive points below the threshold</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def streak_below(self, data: List[Number], num: Number) -&gt; int:
    &#34;&#34;&#34;
    Returns the longest streak that the data points are below some threshold.

    :param data: Data to analyse
    :param num: Threshold value
    :return: Largest count of consecutive points below the threshold
    &#34;&#34;&#34;
    longest = 0
    current = 0
    for d in data:
        if d &lt; num:
            current += 1
            if current &gt; longest:
                longest = current
        else:
            current = 0
    return longest</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.streak_no_cross"><code class="name flex">
<span>def <span class="ident">streak_no_cross</span></span>(<span>self, data:List[Number], num:Number) >Tuple[int,int]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the longest streak of the datapoints not crossing the threshold in either direction and the total
number of times the datapoints cross the threshold.</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd><p>Data to analyse</p></dd>
<dt><strong><code>num</code></strong></dt>
<dd><p>Threshold value</p></dd>
</dl>
<h2 id="returns">Returns:</h2>
<dl>
<dd><p>Tuple of the longest streak and total amount of crossings</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def streak_no_cross(self, data: List[Number], num: Number) -&gt; Tuple[int, int]:
    &#34;&#34;&#34;
    Returns the longest streak of the datapoints not crossing the threshold in either direction and the total
    number of times the datapoints cross the threshold.

    :param data: Data to analyse
    :param num: Threshold value
    :return: Tuple of the longest streak and total amount of crossings
    &#34;&#34;&#34;
    longest = 1
    current = 1
    crossings = 0
    for i in range(len(data) - 1):
        if (data[i] &lt; num) == (data[i + 1] &lt; num):
            current += 1
            if current &gt; longest:
                longest = current
        else:
            current = 1
            crossings += 1
    return longest, crossings</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.succ"><code class="name flex">
<span>def <span class="ident">succ</span></span>(<span>self, c:<a title="tgv.layout.SizedConnectionCluster" href="#tgv.layout.SizedConnectionCluster">SizedConnectionCluster</a>) >Optional[<a title="tgv.layout.SizedConnectionCluster" href="#tgv.layout.SizedConnectionCluster">SizedConnectionCluster</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the successor of this cluster (e.g. the cluster with rank+1)</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>c</code></strong></dt>
<dd><p>Cluster to find the successor of</p></dd>
</dl>
<h2 id="returns">Returns:</h2>
<dl>
<dd><p>SugiyamaCluster or None if no successor exists</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def succ(self, c: SizedConnectionCluster) -&gt; Optional[SizedConnectionCluster]:
    &#34;&#34;&#34;
    Returns the successor of this cluster (e.g. the cluster with rank+1)

    :param c: Cluster to find the successor of
    :return: SugiyamaCluster or None if no successor exists
    &#34;&#34;&#34;
    if c.rank == len(self.layers[c.tc.layer]) - 1:
        return None
    return self.ordered[c.tc.layer][c.rank + 1]</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.swap_align"><code class="name flex">
<span>def <span class="ident">swap_align</span></span>(<span>self, upper:<a title="tgv.layout.SizedConnectionCluster" href="#tgv.layout.SizedConnectionCluster">SizedConnectionCluster</a>, lower:<a title="tgv.layout.SizedConnectionCluster" href="#tgv.layout.SizedConnectionCluster">SizedConnectionCluster</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Count the amount of extra crossings this swap would cause. upper and lower should be in adjacent alignments</p>
<p>Function works by swapping each element and summing the individual differences in crossings</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>upper</code></strong></dt>
<dd><p>cluster in the upper (lower rank) alignment</p></dd>
<dt><strong><code>lower</code></strong></dt>
<dd><p>Cluster in the lower (higher rank) alignment</p></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def swap_align(self, upper: SizedConnectionCluster, lower: SizedConnectionCluster):
    &#34;&#34;&#34;
    Count the amount of extra crossings this swap would cause. upper and lower should be in adjacent alignments

    Function works by swapping each element and summing the individual differences in crossings

    :param upper: cluster in the upper (lower rank) alignment
    :param lower: Cluster in the lower (higher rank) alignment
    &#34;&#34;&#34;
    uroot = upper.root
    lroot = lower.root
    cluster = lroot
    while True:
        predecessor = self.pred(cluster)
        if predecessor is not None and predecessor.root == uroot:
            self.swap_clusters(cluster, predecessor)

        cluster = cluster.align
        if cluster == lroot:
            break</code></pre>
</details>
</dd>
<dt id="tgv.layout.SizedConnectionLayout.swap_clusters"><code class="name flex">
<span>def <span class="ident">swap_clusters</span></span>(<span>self, cluster1:<a title="tgv.layout.SizedConnectionCluster" href="#tgv.layout.SizedConnectionCluster">SizedConnectionCluster</a>, cluster2:<a title="tgv.layout.SizedConnectionCluster" href="#tgv.layout.SizedConnectionCluster">SizedConnectionCluster</a>) >NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Swaps the ordered position/rank of two clusters clusters within the same layer</p>
<h2 id="args">Args:</h2>
<dl>
<dt><strong><code>cluster1</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>cluster2</code></strong></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def swap_clusters(self, cluster1: SizedConnectionCluster, cluster2: SizedConnectionCluster) -&gt; None:
    &#34;&#34;&#34;
    Swaps the ordered position/rank of two clusters clusters within the same layer

    :param cluster1:
    :param cluster2:
    &#34;&#34;&#34;
    order = self.ordered[cluster1.tc.layer]
    order[cluster1.rank], order[cluster2.rank] = order[cluster2.rank], order[cluster1.rank]
    cluster1.rank, cluster2.rank = cluster2.rank, cluster1.rank</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tgv.layout.UnorderedException"><code class="flex name class">
<span>class <span class="ident">UnorderedException</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnorderedException(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tgv" href="index.html">tgv</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tgv.layout.NotEndpointException" href="#tgv.layout.NotEndpointException">NotEndpointException</a></code></h4>
</li>
<li>
<h4><code><a title="tgv.layout.NotRootException" href="#tgv.layout.NotRootException">NotRootException</a></code></h4>
</li>
<li>
<h4><code><a title="tgv.layout.SizedConnectionCluster" href="#tgv.layout.SizedConnectionCluster">SizedConnectionCluster</a></code></h4>
<ul class="">
<li><code><a title="tgv.layout.SizedConnectionCluster.align_with" href="#tgv.layout.SizedConnectionCluster.align_with">align_with</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionCluster.build" href="#tgv.layout.SizedConnectionCluster.build">build</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionCluster.draw_height" href="#tgv.layout.SizedConnectionCluster.draw_height">draw_height</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionCluster.largest_median_connection" href="#tgv.layout.SizedConnectionCluster.largest_median_connection">largest_median_connection</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionCluster.pos" href="#tgv.layout.SizedConnectionCluster.pos">pos</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionCluster.reset_alignment" href="#tgv.layout.SizedConnectionCluster.reset_alignment">reset_alignment</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionCluster.reset_endpoint" href="#tgv.layout.SizedConnectionCluster.reset_endpoint">reset_endpoint</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionCluster.update_cluster_ranks" href="#tgv.layout.SizedConnectionCluster.update_cluster_ranks">update_cluster_ranks</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionCluster.update_cluster_ranks_median" href="#tgv.layout.SizedConnectionCluster.update_cluster_ranks_median">update_cluster_ranks_median</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionCluster.update_wanted_direction" href="#tgv.layout.SizedConnectionCluster.update_wanted_direction">update_wanted_direction</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionCluster.weighted_median_rank" href="#tgv.layout.SizedConnectionCluster.weighted_median_rank">weighted_median_rank</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tgv.layout.SizedConnectionLayout" href="#tgv.layout.SizedConnectionLayout">SizedConnectionLayout</a></code></h4>
<ul class="">
<li><code><a title="tgv.layout.SizedConnectionLayout.adjacent_alignments" href="#tgv.layout.SizedConnectionLayout.adjacent_alignments">adjacent_alignments</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.auto_cluster_width" href="#tgv.layout.SizedConnectionLayout.auto_cluster_width">auto_cluster_width</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.auto_line_width" href="#tgv.layout.SizedConnectionLayout.auto_line_width">auto_line_width</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.avg_block" href="#tgv.layout.SizedConnectionLayout.avg_block">avg_block</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.build_clusters" href="#tgv.layout.SizedConnectionLayout.build_clusters">build_clusters</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.calculate_line_origins" href="#tgv.layout.SizedConnectionLayout.calculate_line_origins">calculate_line_origins</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.center_distance" href="#tgv.layout.SizedConnectionLayout.center_distance">center_distance</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.check_locations" href="#tgv.layout.SizedConnectionLayout.check_locations">check_locations</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.collapse_stairs_iteration" href="#tgv.layout.SizedConnectionLayout.collapse_stairs_iteration">collapse_stairs_iteration</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.crossing_diff_if_swapped" href="#tgv.layout.SizedConnectionLayout.crossing_diff_if_swapped">crossing_diff_if_swapped</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.crossing_diff_if_swapped_align" href="#tgv.layout.SizedConnectionLayout.crossing_diff_if_swapped_align">crossing_diff_if_swapped_align</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.draw_clusters" href="#tgv.layout.SizedConnectionLayout.draw_clusters">draw_clusters</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.draw_connections" href="#tgv.layout.SizedConnectionLayout.draw_connections">draw_connections</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.draw_debug" href="#tgv.layout.SizedConnectionLayout.draw_debug">draw_debug</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.draw_graph" href="#tgv.layout.SizedConnectionLayout.draw_graph">draw_graph</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.draw_line" href="#tgv.layout.SizedConnectionLayout.draw_line">draw_line</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.draw_stats" href="#tgv.layout.SizedConnectionLayout.draw_stats">draw_stats</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.draw_timestamps" href="#tgv.layout.SizedConnectionLayout.draw_timestamps">draw_timestamps</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.fade_cluster" href="#tgv.layout.SizedConnectionLayout.fade_cluster">fade_cluster</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.get_num_crossings" href="#tgv.layout.SizedConnectionLayout.get_num_crossings">get_num_crossings</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.get_stat_height" href="#tgv.layout.SizedConnectionLayout.get_stat_height">get_stat_height</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.get_timestamp_height" href="#tgv.layout.SizedConnectionLayout.get_timestamp_height">get_timestamp_height</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.has_larger_crossings" href="#tgv.layout.SizedConnectionLayout.has_larger_crossings">has_larger_crossings</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.num_shared_neighbours" href="#tgv.layout.SizedConnectionLayout.num_shared_neighbours">num_shared_neighbours</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.place_block" href="#tgv.layout.SizedConnectionLayout.place_block">place_block</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.pred" href="#tgv.layout.SizedConnectionLayout.pred">pred</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.remove_alignments" href="#tgv.layout.SizedConnectionLayout.remove_alignments">remove_alignments</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.reset_alignments" href="#tgv.layout.SizedConnectionLayout.reset_alignments">reset_alignments</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.reset_order" href="#tgv.layout.SizedConnectionLayout.reset_order">reset_order</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.set_alignment" href="#tgv.layout.SizedConnectionLayout.set_alignment">set_alignment</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.set_locations" href="#tgv.layout.SizedConnectionLayout.set_locations">set_locations</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.set_order" href="#tgv.layout.SizedConnectionLayout.set_order">set_order</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.set_x_positions" href="#tgv.layout.SizedConnectionLayout.set_x_positions">set_x_positions</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.set_y_positions" href="#tgv.layout.SizedConnectionLayout.set_y_positions">set_y_positions</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.sort_by_supercluster" href="#tgv.layout.SizedConnectionLayout.sort_by_supercluster">sort_by_supercluster</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.streak_below" href="#tgv.layout.SizedConnectionLayout.streak_below">streak_below</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.streak_no_cross" href="#tgv.layout.SizedConnectionLayout.streak_no_cross">streak_no_cross</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.succ" href="#tgv.layout.SizedConnectionLayout.succ">succ</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.swap_align" href="#tgv.layout.SizedConnectionLayout.swap_align">swap_align</a></code></li>
<li><code><a title="tgv.layout.SizedConnectionLayout.swap_clusters" href="#tgv.layout.SizedConnectionLayout.swap_clusters">swap_clusters</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tgv.layout.UnorderedException" href="#tgv.layout.UnorderedException">UnorderedException</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.3</a>.</p>
</footer>
</body>
</html>